{"ast":null,"code":"// src/utils/excelParser.js - UPDATED VERSION\nimport * as XLSX from 'xlsx';\n\n/**\r\n * Enhanced Excel parser with improved institutional format support\r\n * Handles both .xls and .xlsx files with flexible column detection\r\n */\n\n/**\r\n * Parse Excel file and extract student data\r\n * @param {File} file - Excel file (.xls or .xlsx)\r\n * @returns {Promise<Object>} - Parsed data with students and metadata\r\n */\nexport const parseExcelFile = async file => {\n  try {\n    console.log('üìÅ Reading Excel file:', file.name);\n\n    // Read file as array buffer\n    const arrayBuffer = await file.arrayBuffer();\n\n    // Parse workbook\n    const workbook = XLSX.read(arrayBuffer, {\n      type: 'array',\n      cellStyles: false,\n      cellDates: true,\n      dateNF: 'YYYY-MM-DD'\n    });\n    console.log('üìä Workbook sheets:', workbook.SheetNames);\n\n    // Get first sheet\n    const firstSheetName = workbook.SheetNames[0];\n    const worksheet = workbook.Sheets[firstSheetName];\n\n    // Convert to JSON with header row\n    const jsonData = XLSX.utils.sheet_to_json(worksheet, {\n      header: 1,\n      raw: false,\n      defval: ''\n    });\n    console.log('üìã Raw data rows:', jsonData.length);\n    console.log('üìã First few rows:', jsonData.slice(0, 5));\n    if (jsonData.length < 2) {\n      throw new Error('File appears to be empty or has no data rows');\n    }\n\n    // Extract headers (first non-empty row)\n    let headerRow = null;\n    let dataStartIndex = 0;\n    for (let i = 0; i < jsonData.length; i++) {\n      const row = jsonData[i];\n      if (row && row.length > 0 && row.some(cell => cell && cell.toString().trim())) {\n        // Check if this looks like a header row\n        const cellsWithText = row.filter(cell => cell && cell.toString().trim()).length;\n        if (cellsWithText >= 3) {\n          // Must have at least 3 non-empty cells\n          headerRow = row;\n          dataStartIndex = i + 1;\n          break;\n        }\n      }\n    }\n    if (!headerRow) {\n      throw new Error('Could not find header row in Excel file');\n    }\n    console.log('üìù Headers found:', headerRow);\n    console.log('üìç Data starts at row:', dataStartIndex + 1);\n\n    // Detect column mapping\n    const columnMapping = detectColumns(headerRow);\n    console.log('üîç Column mapping:', columnMapping);\n    if (Object.keys(columnMapping).length === 0) {\n      console.error('‚ùå No columns detected. Headers:', headerRow);\n      throw new Error('Could not detect student information columns. Please check that your Excel file contains columns for student ID, name, and email.');\n    }\n\n    // Extract course information from the file\n    const courseInfo = extractCourseInfo(jsonData, headerRow);\n    console.log('üéì Course info extracted:', courseInfo);\n\n    // Parse student data\n    const students = parseStudentData(jsonData.slice(dataStartIndex), columnMapping);\n    console.log('üë• Students parsed:', students.length);\n    if (students.length === 0) {\n      throw new Error('No valid student data found. Please ensure your Excel file contains student information with ID, Name, and Email columns.');\n    }\n    return {\n      success: true,\n      students,\n      courseInfo,\n      metadata: {\n        fileName: file.name,\n        totalRows: jsonData.length,\n        dataRows: jsonData.length - dataStartIndex,\n        studentsFound: students.length,\n        columnsDetected: Object.keys(columnMapping).length,\n        headers: headerRow,\n        columnMapping\n      }\n    };\n  } catch (error) {\n    console.error('‚ùå Excel parsing error:', error);\n    return {\n      success: false,\n      error: error.message,\n      students: [],\n      courseInfo: {},\n      metadata: {\n        fileName: file.name,\n        error: error.message\n      }\n    };\n  }\n};\n\n/**\r\n * Detect column mapping from headers with enhanced institutional support\r\n * @param {Array} headers - Header row from Excel\r\n * @returns {Object} - Mapping of column indices to data types\r\n */\nconst detectColumns = headers => {\n  const mapping = {};\n\n  // Enhanced column detection patterns for institutional formats\n  const patterns = {\n    id: ['id', 'student id', 'studentid', 'student_id', 'number', 'student number', 'studentnumber', 'student_number', 'matric', 'matriculation', 'registration', 'reg', 'user id', 'userid', 'user_id'],\n    name: ['name', 'student name', 'studentname', 'student_name', 'full name', 'fullname', 'full_name', 'first name', 'firstname', 'last name', 'lastname', 'student', 'display name', 'displayname'],\n    email: ['email', 'email address', 'emailaddress', 'email_address', 'student email', 'studentemail', 'student_email', 'contact', 'e-mail', 'mail'],\n    program: ['program', 'program code', 'programcode', 'program_code', 'course', 'course code', 'coursecode', 'course_code', 'major', 'degree', 'field', 'discipline'],\n    level: ['level', 'year', 'year level', 'yearlevel', 'year_level', 'semester', 'term', 'grade', 'class', 'standing', 'academic level', 'academiclevel'],\n    status: ['status', 'enrollment', 'enrollment status', 'enrollmentstatus', 'active', 'enrolled', 'registration status', 'reg status', 'student status', 'studentstatus'],\n    section: ['section', 'class', 'group', 'class section', 'classsection', 'component', 'session', 'lab', 'tutorial'],\n    campus: ['campus', 'location', 'site', 'campus location', 'facility', 'branch']\n  };\n  headers.forEach((header, index) => {\n    if (!header) return;\n    const normalizedHeader = header.toString().toLowerCase().trim();\n    console.log(`üîç Checking header ${index}: \"${header}\" (normalized: \"${normalizedHeader}\")`);\n\n    // Check each pattern type\n    for (const [type, patternList] of Object.entries(patterns)) {\n      for (const pattern of patternList) {\n        if (normalizedHeader === pattern || normalizedHeader.includes(pattern) || pattern.includes(normalizedHeader)) {\n          console.log(`‚úÖ Matched \"${header}\" -> ${type} (pattern: \"${pattern}\")`);\n          mapping[type] = index;\n          break;\n        }\n      }\n\n      // Break outer loop if found\n      if (mapping[type] !== undefined) break;\n    }\n  });\n  console.log('üéØ Final column mapping:', mapping);\n  return mapping;\n};\n\n/**\r\n * Extract course information from Excel data\r\n * @param {Array} data - Raw Excel data\r\n * @param {Array} headers - Header row\r\n * @returns {Object} - Course information\r\n */\nconst extractCourseInfo = (data, headers) => {\n  const courseInfo = {};\n\n  // Look for course info in early rows (before student data)\n  const searchRows = data.slice(0, Math.min(10, data.length));\n  for (const row of searchRows) {\n    if (!row || row.length === 0) continue;\n    const rowText = row.join(' ').toLowerCase();\n\n    // Extract course code (pattern: letters + numbers)\n    const courseCodeMatch = rowText.match(/([a-z]{2,4}\\d{3,4})/i);\n    if (courseCodeMatch && !courseInfo.code) {\n      courseInfo.code = courseCodeMatch[1].toUpperCase();\n    }\n\n    // Extract course name (look for \"course:\" or similar patterns)\n    const courseNameMatch = rowText.match(/course[:\\s]*([^|,\\n]+)/i);\n    if (courseNameMatch && !courseInfo.name) {\n      courseInfo.name = courseNameMatch[1].trim();\n    }\n\n    // Extract semester/term info\n    const termMatch = rowText.match(/(fall|winter|spring|summer)\\s*\\d{4}/i);\n    if (termMatch && !courseInfo.term) {\n      courseInfo.term = termMatch[0];\n    }\n\n    // Look for \"offered:\" or \"hours:\" patterns\n    const offeredMatch = rowText.match(/offered[:\\s]*([^|,\\n]+)/i);\n    if (offeredMatch && !courseInfo.offered) {\n      courseInfo.offered = offeredMatch[1].trim();\n    }\n  }\n  return courseInfo;\n};\n\n/**\r\n * Parse student data from rows using column mapping\r\n * @param {Array} rows - Data rows from Excel\r\n * @param {Object} mapping - Column mapping object\r\n * @returns {Array} - Array of student objects\r\n */\nconst parseStudentData = (rows, mapping) => {\n  const students = [];\n  console.log('üë• Processing student data rows:', rows.length);\n  console.log('üó∫Ô∏è Using column mapping:', mapping);\n  rows.forEach((row, index) => {\n    try {\n      if (!row || row.length === 0) return;\n\n      // Skip empty or header-like rows\n      const nonEmptyCells = row.filter(cell => cell && cell.toString().trim()).length;\n      if (nonEmptyCells < 2) return;\n\n      // Extract data using mapping\n      const studentData = {};\n\n      // Get required fields\n      if (mapping.id !== undefined) {\n        studentData.id = row[mapping.id] ? row[mapping.id].toString().trim() : '';\n      }\n      if (mapping.name !== undefined) {\n        studentData.name = row[mapping.name] ? row[mapping.name].toString().trim() : '';\n      }\n      if (mapping.email !== undefined) {\n        studentData.email = row[mapping.email] ? row[mapping.email].toString().trim() : '';\n      }\n\n      // Get optional fields\n      if (mapping.program !== undefined) {\n        studentData.program = row[mapping.program] ? row[mapping.program].toString().trim() : '';\n      }\n      if (mapping.level !== undefined) {\n        studentData.level = row[mapping.level] ? row[mapping.level].toString().trim() : '';\n      }\n      if (mapping.status !== undefined) {\n        studentData.status = row[mapping.status] ? row[mapping.status].toString().trim() : '';\n      }\n      if (mapping.section !== undefined) {\n        studentData.section = row[mapping.section] ? row[mapping.section].toString().trim() : '';\n      }\n      if (mapping.campus !== undefined) {\n        studentData.campus = row[mapping.campus] ? row[mapping.campus].toString().trim() : '';\n      }\n      console.log(`üë§ Row ${index + 1} data:`, studentData);\n\n      // Validate required fields\n      if (!studentData.id && !studentData.name) {\n        console.log(`‚ö†Ô∏è Skipping row ${index + 1}: Missing both ID and name`);\n        return;\n      }\n\n      // Add to students array with additional metadata\n      students.push({\n        ...studentData,\n        originalRow: index + 1,\n        rawData: row\n      });\n    } catch (error) {\n      console.error(`‚ùå Error processing row ${index + 1}:`, error, row);\n    }\n  });\n  console.log(`‚úÖ Successfully parsed ${students.length} students`);\n  return students;\n};\n\n/**\r\n * Validate parsed student data\r\n * @param {Array} students - Array of student objects\r\n * @returns {Object} - Validation results\r\n */\nexport const validateStudentData = students => {\n  const validation = {\n    valid: [],\n    invalid: [],\n    warnings: [],\n    summary: {}\n  };\n  students.forEach((student, index) => {\n    const issues = [];\n\n    // Check required fields\n    if (!student.id) issues.push('Missing student ID');\n    if (!student.name) issues.push('Missing student name');\n\n    // Check email format if provided\n    if (student.email && !isValidEmail(student.email)) {\n      issues.push('Invalid email format');\n    }\n    if (issues.length === 0) {\n      validation.valid.push(student);\n    } else {\n      validation.invalid.push({\n        ...student,\n        issues\n      });\n    }\n  });\n\n  // Generate summary\n  validation.summary = {\n    total: students.length,\n    valid: validation.valid.length,\n    invalid: validation.invalid.length,\n    completeness: validation.valid.length / students.length\n  };\n  return validation;\n};\n\n/**\r\n * Simple email validation\r\n * @param {string} email - Email to validate\r\n * @returns {boolean} - Is valid email\r\n */\nconst isValidEmail = email => {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n};\nexport default {\n  parseExcelFile,\n  validateStudentData\n};","map":{"version":3,"names":["XLSX","parseExcelFile","file","console","log","name","arrayBuffer","workbook","read","type","cellStyles","cellDates","dateNF","SheetNames","firstSheetName","worksheet","Sheets","jsonData","utils","sheet_to_json","header","raw","defval","length","slice","Error","headerRow","dataStartIndex","i","row","some","cell","toString","trim","cellsWithText","filter","columnMapping","detectColumns","Object","keys","error","courseInfo","extractCourseInfo","students","parseStudentData","success","metadata","fileName","totalRows","dataRows","studentsFound","columnsDetected","headers","message","mapping","patterns","id","email","program","level","status","section","campus","forEach","index","normalizedHeader","toLowerCase","patternList","entries","pattern","includes","undefined","data","searchRows","Math","min","rowText","join","courseCodeMatch","match","code","toUpperCase","courseNameMatch","termMatch","term","offeredMatch","offered","rows","nonEmptyCells","studentData","push","originalRow","rawData","validateStudentData","validation","valid","invalid","warnings","summary","student","issues","isValidEmail","total","completeness","emailRegex","test"],"sources":["C:/local clones/rubric-creation-app/src/utils/excelParser.js"],"sourcesContent":["// src/utils/excelParser.js - UPDATED VERSION\r\nimport * as XLSX from 'xlsx';\r\n\r\n/**\r\n * Enhanced Excel parser with improved institutional format support\r\n * Handles both .xls and .xlsx files with flexible column detection\r\n */\r\n\r\n/**\r\n * Parse Excel file and extract student data\r\n * @param {File} file - Excel file (.xls or .xlsx)\r\n * @returns {Promise<Object>} - Parsed data with students and metadata\r\n */\r\nexport const parseExcelFile = async (file) => {\r\n    try {\r\n        console.log('üìÅ Reading Excel file:', file.name);\r\n\r\n        // Read file as array buffer\r\n        const arrayBuffer = await file.arrayBuffer();\r\n\r\n        // Parse workbook\r\n        const workbook = XLSX.read(arrayBuffer, {\r\n            type: 'array',\r\n            cellStyles: false,\r\n            cellDates: true,\r\n            dateNF: 'YYYY-MM-DD'\r\n        });\r\n\r\n        console.log('üìä Workbook sheets:', workbook.SheetNames);\r\n\r\n        // Get first sheet\r\n        const firstSheetName = workbook.SheetNames[0];\r\n        const worksheet = workbook.Sheets[firstSheetName];\r\n\r\n        // Convert to JSON with header row\r\n        const jsonData = XLSX.utils.sheet_to_json(worksheet, {\r\n            header: 1,\r\n            raw: false,\r\n            defval: ''\r\n        });\r\n\r\n        console.log('üìã Raw data rows:', jsonData.length);\r\n        console.log('üìã First few rows:', jsonData.slice(0, 5));\r\n\r\n        if (jsonData.length < 2) {\r\n            throw new Error('File appears to be empty or has no data rows');\r\n        }\r\n\r\n        // Extract headers (first non-empty row)\r\n        let headerRow = null;\r\n        let dataStartIndex = 0;\r\n\r\n        for (let i = 0; i < jsonData.length; i++) {\r\n            const row = jsonData[i];\r\n            if (row && row.length > 0 && row.some(cell => cell && cell.toString().trim())) {\r\n                // Check if this looks like a header row\r\n                const cellsWithText = row.filter(cell => cell && cell.toString().trim()).length;\r\n                if (cellsWithText >= 3) { // Must have at least 3 non-empty cells\r\n                    headerRow = row;\r\n                    dataStartIndex = i + 1;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!headerRow) {\r\n            throw new Error('Could not find header row in Excel file');\r\n        }\r\n\r\n        console.log('üìù Headers found:', headerRow);\r\n        console.log('üìç Data starts at row:', dataStartIndex + 1);\r\n\r\n        // Detect column mapping\r\n        const columnMapping = detectColumns(headerRow);\r\n        console.log('üîç Column mapping:', columnMapping);\r\n\r\n        if (Object.keys(columnMapping).length === 0) {\r\n            console.error('‚ùå No columns detected. Headers:', headerRow);\r\n            throw new Error('Could not detect student information columns. Please check that your Excel file contains columns for student ID, name, and email.');\r\n        }\r\n\r\n        // Extract course information from the file\r\n        const courseInfo = extractCourseInfo(jsonData, headerRow);\r\n        console.log('üéì Course info extracted:', courseInfo);\r\n\r\n        // Parse student data\r\n        const students = parseStudentData(jsonData.slice(dataStartIndex), columnMapping);\r\n        console.log('üë• Students parsed:', students.length);\r\n\r\n        if (students.length === 0) {\r\n            throw new Error('No valid student data found. Please ensure your Excel file contains student information with ID, Name, and Email columns.');\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            students,\r\n            courseInfo,\r\n            metadata: {\r\n                fileName: file.name,\r\n                totalRows: jsonData.length,\r\n                dataRows: jsonData.length - dataStartIndex,\r\n                studentsFound: students.length,\r\n                columnsDetected: Object.keys(columnMapping).length,\r\n                headers: headerRow,\r\n                columnMapping\r\n            }\r\n        };\r\n\r\n    } catch (error) {\r\n        console.error('‚ùå Excel parsing error:', error);\r\n        return {\r\n            success: false,\r\n            error: error.message,\r\n            students: [],\r\n            courseInfo: {},\r\n            metadata: {\r\n                fileName: file.name,\r\n                error: error.message\r\n            }\r\n        };\r\n    }\r\n};\r\n\r\n/**\r\n * Detect column mapping from headers with enhanced institutional support\r\n * @param {Array} headers - Header row from Excel\r\n * @returns {Object} - Mapping of column indices to data types\r\n */\r\nconst detectColumns = (headers) => {\r\n    const mapping = {};\r\n\r\n    // Enhanced column detection patterns for institutional formats\r\n    const patterns = {\r\n        id: [\r\n            'id', 'student id', 'studentid', 'student_id',\r\n            'number', 'student number', 'studentnumber', 'student_number',\r\n            'matric', 'matriculation', 'registration', 'reg',\r\n            'user id', 'userid', 'user_id'\r\n        ],\r\n        name: [\r\n            'name', 'student name', 'studentname', 'student_name',\r\n            'full name', 'fullname', 'full_name',\r\n            'first name', 'firstname', 'last name', 'lastname',\r\n            'student', 'display name', 'displayname'\r\n        ],\r\n        email: [\r\n            'email', 'email address', 'emailaddress', 'email_address',\r\n            'student email', 'studentemail', 'student_email',\r\n            'contact', 'e-mail', 'mail'\r\n        ],\r\n        program: [\r\n            'program', 'program code', 'programcode', 'program_code',\r\n            'course', 'course code', 'coursecode', 'course_code',\r\n            'major', 'degree', 'field', 'discipline'\r\n        ],\r\n        level: [\r\n            'level', 'year', 'year level', 'yearlevel', 'year_level',\r\n            'semester', 'term', 'grade', 'class',\r\n            'standing', 'academic level', 'academiclevel'\r\n        ],\r\n        status: [\r\n            'status', 'enrollment', 'enrollment status', 'enrollmentstatus',\r\n            'active', 'enrolled', 'registration status', 'reg status',\r\n            'student status', 'studentstatus'\r\n        ],\r\n        section: [\r\n            'section', 'class', 'group', 'class section', 'classsection',\r\n            'component', 'session', 'lab', 'tutorial'\r\n        ],\r\n        campus: [\r\n            'campus', 'location', 'site', 'campus location',\r\n            'facility', 'branch'\r\n        ]\r\n    };\r\n\r\n    headers.forEach((header, index) => {\r\n        if (!header) return;\r\n\r\n        const normalizedHeader = header.toString().toLowerCase().trim();\r\n        console.log(`üîç Checking header ${index}: \"${header}\" (normalized: \"${normalizedHeader}\")`);\r\n\r\n        // Check each pattern type\r\n        for (const [type, patternList] of Object.entries(patterns)) {\r\n            for (const pattern of patternList) {\r\n                if (normalizedHeader === pattern ||\r\n                    normalizedHeader.includes(pattern) ||\r\n                    pattern.includes(normalizedHeader)) {\r\n\r\n                    console.log(`‚úÖ Matched \"${header}\" -> ${type} (pattern: \"${pattern}\")`);\r\n                    mapping[type] = index;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Break outer loop if found\r\n            if (mapping[type] !== undefined) break;\r\n        }\r\n    });\r\n\r\n    console.log('üéØ Final column mapping:', mapping);\r\n    return mapping;\r\n};\r\n\r\n/**\r\n * Extract course information from Excel data\r\n * @param {Array} data - Raw Excel data\r\n * @param {Array} headers - Header row\r\n * @returns {Object} - Course information\r\n */\r\nconst extractCourseInfo = (data, headers) => {\r\n    const courseInfo = {};\r\n\r\n    // Look for course info in early rows (before student data)\r\n    const searchRows = data.slice(0, Math.min(10, data.length));\r\n\r\n    for (const row of searchRows) {\r\n        if (!row || row.length === 0) continue;\r\n\r\n        const rowText = row.join(' ').toLowerCase();\r\n\r\n        // Extract course code (pattern: letters + numbers)\r\n        const courseCodeMatch = rowText.match(/([a-z]{2,4}\\d{3,4})/i);\r\n        if (courseCodeMatch && !courseInfo.code) {\r\n            courseInfo.code = courseCodeMatch[1].toUpperCase();\r\n        }\r\n\r\n        // Extract course name (look for \"course:\" or similar patterns)\r\n        const courseNameMatch = rowText.match(/course[:\\s]*([^|,\\n]+)/i);\r\n        if (courseNameMatch && !courseInfo.name) {\r\n            courseInfo.name = courseNameMatch[1].trim();\r\n        }\r\n\r\n        // Extract semester/term info\r\n        const termMatch = rowText.match(/(fall|winter|spring|summer)\\s*\\d{4}/i);\r\n        if (termMatch && !courseInfo.term) {\r\n            courseInfo.term = termMatch[0];\r\n        }\r\n\r\n        // Look for \"offered:\" or \"hours:\" patterns\r\n        const offeredMatch = rowText.match(/offered[:\\s]*([^|,\\n]+)/i);\r\n        if (offeredMatch && !courseInfo.offered) {\r\n            courseInfo.offered = offeredMatch[1].trim();\r\n        }\r\n    }\r\n\r\n    return courseInfo;\r\n};\r\n\r\n/**\r\n * Parse student data from rows using column mapping\r\n * @param {Array} rows - Data rows from Excel\r\n * @param {Object} mapping - Column mapping object\r\n * @returns {Array} - Array of student objects\r\n */\r\nconst parseStudentData = (rows, mapping) => {\r\n    const students = [];\r\n\r\n    console.log('üë• Processing student data rows:', rows.length);\r\n    console.log('üó∫Ô∏è Using column mapping:', mapping);\r\n\r\n    rows.forEach((row, index) => {\r\n        try {\r\n            if (!row || row.length === 0) return;\r\n\r\n            // Skip empty or header-like rows\r\n            const nonEmptyCells = row.filter(cell => cell && cell.toString().trim()).length;\r\n            if (nonEmptyCells < 2) return;\r\n\r\n            // Extract data using mapping\r\n            const studentData = {};\r\n\r\n            // Get required fields\r\n            if (mapping.id !== undefined) {\r\n                studentData.id = row[mapping.id] ? row[mapping.id].toString().trim() : '';\r\n            }\r\n\r\n            if (mapping.name !== undefined) {\r\n                studentData.name = row[mapping.name] ? row[mapping.name].toString().trim() : '';\r\n            }\r\n\r\n            if (mapping.email !== undefined) {\r\n                studentData.email = row[mapping.email] ? row[mapping.email].toString().trim() : '';\r\n            }\r\n\r\n            // Get optional fields\r\n            if (mapping.program !== undefined) {\r\n                studentData.program = row[mapping.program] ? row[mapping.program].toString().trim() : '';\r\n            }\r\n\r\n            if (mapping.level !== undefined) {\r\n                studentData.level = row[mapping.level] ? row[mapping.level].toString().trim() : '';\r\n            }\r\n\r\n            if (mapping.status !== undefined) {\r\n                studentData.status = row[mapping.status] ? row[mapping.status].toString().trim() : '';\r\n            }\r\n\r\n            if (mapping.section !== undefined) {\r\n                studentData.section = row[mapping.section] ? row[mapping.section].toString().trim() : '';\r\n            }\r\n\r\n            if (mapping.campus !== undefined) {\r\n                studentData.campus = row[mapping.campus] ? row[mapping.campus].toString().trim() : '';\r\n            }\r\n\r\n            console.log(`üë§ Row ${index + 1} data:`, studentData);\r\n\r\n            // Validate required fields\r\n            if (!studentData.id && !studentData.name) {\r\n                console.log(`‚ö†Ô∏è Skipping row ${index + 1}: Missing both ID and name`);\r\n                return;\r\n            }\r\n\r\n            // Add to students array with additional metadata\r\n            students.push({\r\n                ...studentData,\r\n                originalRow: index + 1,\r\n                rawData: row\r\n            });\r\n\r\n        } catch (error) {\r\n            console.error(`‚ùå Error processing row ${index + 1}:`, error, row);\r\n        }\r\n    });\r\n\r\n    console.log(`‚úÖ Successfully parsed ${students.length} students`);\r\n    return students;\r\n};\r\n\r\n/**\r\n * Validate parsed student data\r\n * @param {Array} students - Array of student objects\r\n * @returns {Object} - Validation results\r\n */\r\nexport const validateStudentData = (students) => {\r\n    const validation = {\r\n        valid: [],\r\n        invalid: [],\r\n        warnings: [],\r\n        summary: {}\r\n    };\r\n\r\n    students.forEach((student, index) => {\r\n        const issues = [];\r\n\r\n        // Check required fields\r\n        if (!student.id) issues.push('Missing student ID');\r\n        if (!student.name) issues.push('Missing student name');\r\n\r\n        // Check email format if provided\r\n        if (student.email && !isValidEmail(student.email)) {\r\n            issues.push('Invalid email format');\r\n        }\r\n\r\n        if (issues.length === 0) {\r\n            validation.valid.push(student);\r\n        } else {\r\n            validation.invalid.push({\r\n                ...student,\r\n                issues\r\n            });\r\n        }\r\n    });\r\n\r\n    // Generate summary\r\n    validation.summary = {\r\n        total: students.length,\r\n        valid: validation.valid.length,\r\n        invalid: validation.invalid.length,\r\n        completeness: validation.valid.length / students.length\r\n    };\r\n\r\n    return validation;\r\n};\r\n\r\n/**\r\n * Simple email validation\r\n * @param {string} email - Email to validate\r\n * @returns {boolean} - Is valid email\r\n */\r\nconst isValidEmail = (email) => {\r\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n    return emailRegex.test(email);\r\n};\r\n\r\nexport default {\r\n    parseExcelFile,\r\n    validateStudentData\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}