{"ast":null,"code":"// Enhanced excelParser.js - Fixed version with proper table detection\nimport * as XLSX from 'xlsx';\n\n/**\r\n * Parse Excel file and extract student data with enhanced table detection\r\n * @param {File} file - Excel file to parse\r\n * @returns {Promise<Object>} - Parsed data with students array and metadata\r\n */\nexport const parseExcelFile = async file => {\n  try {\n    console.log('üîç Starting Excel file parsing:', file.name);\n    const arrayBuffer = await file.arrayBuffer();\n    const workbook = XLSX.read(arrayBuffer, {\n      type: 'array'\n    });\n    const firstSheetName = workbook.SheetNames[0];\n    const worksheet = workbook.Sheets[firstSheetName];\n    console.log('üìä Workbook sheets:', workbook.SheetNames);\n\n    // Convert to array of arrays for easier processing\n    const rawData = XLSX.utils.sheet_to_json(worksheet, {\n      header: 1,\n      defval: '',\n      blankrows: false\n    });\n    console.log(`üìã Total rows in Excel: ${rawData.length}`);\n    console.log('üîç First 15 rows for debugging:', rawData.slice(0, 15));\n\n    // Enhanced table detection\n    const tableInfo = findStudentDataTable(rawData);\n    if (!tableInfo.found) {\n      throw new Error('Could not locate student data table in Excel file');\n    }\n    console.log(`‚úÖ Student data table found:`, tableInfo);\n\n    // Extract headers and data\n    const headers = rawData[tableInfo.headerRow];\n    const dataRows = rawData.slice(tableInfo.dataStartRow, tableInfo.dataEndRow + 1);\n    console.log('üìë Detected headers:', headers);\n    console.log(`üìä Data rows to process: ${dataRows.length}`);\n\n    // Parse student data with enhanced mapping\n    const students = parseStudentData(headers, dataRows);\n    console.log(`üéì Successfully parsed ${students.length} students`);\n    return {\n      students,\n      totalRows: rawData.length,\n      dataRows: dataRows.length,\n      headers,\n      tableInfo,\n      success: true,\n      message: `Successfully parsed ${students.length} students from ${dataRows.length} data rows`\n    };\n  } catch (error) {\n    console.error('‚ùå Excel parsing error:', error);\n    return {\n      students: [],\n      success: false,\n      error: error.message,\n      suggestions: ['Ensure the Excel file contains a student data table', 'Check that student IDs are in 6-digit format (e.g., 400001)', 'Verify column headers include ID, Name, Email, etc.', 'Make sure the file is not corrupted or password protected']\n    };\n  }\n};\n\n/**\r\n * Enhanced function to find the actual student data table within the Excel file\r\n * @param {Array} rawData - Raw Excel data as array of arrays\r\n * @returns {Object} - Table location information\r\n */\nconst findStudentDataTable = rawData => {\n  console.log('üîç Searching for student data table...');\n\n  // Look for student ID patterns and data table indicators\n  for (let rowIndex = 0; rowIndex < Math.min(rawData.length, 30); rowIndex++) {\n    const row = rawData[rowIndex];\n    if (!row || row.length === 0) continue;\n\n    // Check if this row contains student ID patterns (6-digit numbers starting with 4)\n    const hasStudentIDs = row.some(cell => {\n      const cellStr = String(cell).trim();\n      return /^4\\d{5}$/.test(cellStr); // Matches 400001, 400002, etc.\n    });\n    if (hasStudentIDs) {\n      console.log(`üéØ Found student IDs in row ${rowIndex}:`, row);\n\n      // Look backwards for the header row\n      const headerRow = findHeaderRow(rawData, rowIndex);\n      if (headerRow !== -1) {\n        // Find the end of data table\n        const dataEndRow = findDataEndRow(rawData, rowIndex);\n        return {\n          found: true,\n          headerRow,\n          dataStartRow: rowIndex,\n          dataEndRow,\n          firstStudentRow: rowIndex,\n          studentsFound: dataEndRow - rowIndex + 1\n        };\n      }\n    }\n  }\n\n  // Fallback: Look for institutional header patterns\n  for (let rowIndex = 0; rowIndex < Math.min(rawData.length, 25); rowIndex++) {\n    const row = rawData[rowIndex];\n    if (!row || row.length < 5) continue;\n\n    // Check for institutional column header patterns\n    const headerScore = calculateHeaderScore(row);\n    if (headerScore >= 3) {\n      // Need at least 3 matching column patterns\n      console.log(`üìã Found potential headers in row ${rowIndex}:`, row);\n\n      // Look for data rows following this header\n      const dataStartRow = rowIndex + 1;\n      const dataEndRow = findDataEndRow(rawData, dataStartRow);\n      if (dataEndRow > dataStartRow) {\n        return {\n          found: true,\n          headerRow: rowIndex,\n          dataStartRow,\n          dataEndRow,\n          studentsFound: dataEndRow - dataStartRow + 1\n        };\n      }\n    }\n  }\n  return {\n    found: false\n  };\n};\n\n/**\r\n * Find the header row by looking backwards from a student data row\r\n * @param {Array} rawData - Raw Excel data\r\n * @param {number} studentRowIndex - Index of row containing student data\r\n * @returns {number} - Header row index or -1 if not found\r\n */\nconst findHeaderRow = (rawData, studentRowIndex) => {\n  // Look up to 5 rows back for headers\n  for (let i = Math.max(0, studentRowIndex - 5); i < studentRowIndex; i++) {\n    const row = rawData[i];\n    if (!row || row.length === 0) continue;\n    const headerScore = calculateHeaderScore(row);\n    if (headerScore >= 3) {\n      console.log(`üìã Found header row ${i} with score ${headerScore}:`, row);\n      return i;\n    }\n  }\n\n  // If no clear headers found, assume the row immediately before student data\n  return Math.max(0, studentRowIndex - 1);\n};\n\n/**\r\n * Find the end of the data table\r\n * @param {Array} rawData - Raw Excel data\r\n * @param {number} startRow - Starting row index\r\n * @returns {number} - Last row index with data\r\n */\nconst findDataEndRow = (rawData, startRow) => {\n  let lastDataRow = startRow;\n  for (let i = startRow; i < rawData.length; i++) {\n    const row = rawData[i];\n\n    // Stop if we hit an empty row or summary information\n    if (!row || row.length === 0) break;\n\n    // Stop if we hit administrative text like \"Total Students:\" or \"Signature\"\n    const rowText = row.join(' ').toLowerCase();\n    if (rowText.includes('total') || rowText.includes('signature') || rowText.includes('professor') || rowText.includes('page ')) {\n      break;\n    }\n\n    // Continue if row has substantial data (at least 3 non-empty cells)\n    const nonEmptyCells = row.filter(cell => cell !== null && cell !== undefined && String(cell).trim() !== '').length;\n    if (nonEmptyCells >= 3) {\n      lastDataRow = i;\n    } else if (i > startRow + 2) {\n      // If we've seen some data and now have sparse rows, probably end of table\n      break;\n    }\n  }\n  return lastDataRow;\n};\n\n/**\r\n * Calculate how likely a row is to contain column headers\r\n * @param {Array} row - Row data\r\n * @returns {number} - Score (0-7) indicating likelihood of being headers\r\n */\nconst calculateHeaderScore = row => {\n  let score = 0;\n  const rowStr = row.join(' ').toLowerCase();\n\n  // Institutional header patterns with flexible matching\n  const headerPatterns = {\n    id: ['component', 'id', 'student id', 'studentid', 'number'],\n    name: ['name', 'student name', 'full name', 'student'],\n    email: ['email', 'e-mail', 'student email', 'emailaddress'],\n    program: ['program', 'course', 'programcode', 'coursecode'],\n    level: ['level', 'year', 'semester', 'term', 'grade'],\n    status: ['status', 'enrollment', 'active', 'enrolled'],\n    campus: ['campus', 'location', 'site']\n  };\n\n  // Check each cell for header patterns\n  row.forEach(cell => {\n    const cellStr = String(cell).trim().toLowerCase();\n    if (cellStr.length === 0) return;\n\n    // Check against all pattern categories\n    Object.values(headerPatterns).forEach(patterns => {\n      if (patterns.some(pattern => cellStr.includes(pattern) || pattern.includes(cellStr))) {\n        score++;\n      }\n    });\n  });\n  console.log(`üìä Header score for row: ${score}`, row);\n  return score;\n};\n\n/**\r\n * Enhanced student data parsing with better column mapping\r\n * @param {Array} headers - Column headers\r\n * @param {Array} dataRows - Data rows to parse\r\n * @returns {Array} - Array of student objects\r\n */\nconst parseStudentData = (headers, dataRows) => {\n  console.log('üîÑ Parsing student data with headers:', headers);\n\n  // Enhanced column mapping\n  const columnMap = mapColumns(headers);\n  console.log('üìç Column mapping:', columnMap);\n  const students = [];\n  dataRows.forEach((row, index) => {\n    try {\n      // Skip empty rows\n      if (!row || row.length === 0) return;\n\n      // Extract student data using column mapping\n      const student = {\n        id: getColumnValue(row, columnMap.id),\n        name: getColumnValue(row, columnMap.name),\n        email: getColumnValue(row, columnMap.email),\n        program: getColumnValue(row, columnMap.program),\n        level: getColumnValue(row, columnMap.level),\n        campus: getColumnValue(row, columnMap.campus),\n        status: getColumnValue(row, columnMap.status),\n        component: getColumnValue(row, columnMap.component),\n        originalRow: index,\n        rawData: row\n      };\n\n      // Validate student data - require at least ID and name\n      if (student.id && student.name && String(student.id).trim() !== '' && String(student.name).trim() !== '') {\n        // Clean up data\n        student.id = String(student.id).trim();\n        student.name = String(student.name).trim();\n        student.email = String(student.email || '').trim();\n        student.program = String(student.program || '').trim();\n        student.level = String(student.level || '').trim();\n        student.campus = String(student.campus || '').trim();\n        student.status = String(student.status || '').trim();\n        students.push(student);\n        console.log(`‚úÖ Parsed student ${students.length}:`, student);\n      } else {\n        console.log(`‚ö†Ô∏è Skipping invalid row ${index}:`, student);\n      }\n    } catch (error) {\n      console.error(`‚ùå Error parsing row ${index}:`, error, row);\n    }\n  });\n  return students;\n};\n\n/**\r\n * Enhanced column mapping with institutional patterns\r\n * @param {Array} headers - Header row\r\n * @returns {Object} - Column index mapping\r\n */\nconst mapColumns = headers => {\n  const mapping = {};\n\n  // Enhanced patterns for institutional Excel files\n  const patterns = {\n    component: ['component', 'session', 'section', 'class'],\n    id: ['id', 'student id', 'studentid', 'number', 'student number'],\n    name: ['name', 'student name', 'full name', 'student'],\n    email: ['email', 'e-mail', 'student email', 'emailaddress'],\n    program: ['program', 'course', 'programcode', 'coursecode', 'course code'],\n    level: ['level', 'year', 'semester', 'term', 'grade'],\n    campus: ['campus', 'location', 'site'],\n    status: ['status', 'enrollment', 'active', 'enrolled', 'standing']\n  };\n\n  // Map each header to a column type\n  headers.forEach((header, index) => {\n    const headerStr = String(header).trim().toLowerCase();\n    if (headerStr.length === 0) return;\n\n    // Check against each pattern category\n    Object.entries(patterns).forEach(([key, patternList]) => {\n      if (!mapping[key]) {\n        // Only assign if not already mapped\n        const match = patternList.some(pattern => headerStr.includes(pattern) || pattern.includes(headerStr));\n        if (match) {\n          mapping[key] = index;\n          console.log(`üìç Mapped \"${header}\" (index ${index}) to ${key}`);\n        }\n      }\n    });\n  });\n  return mapping;\n};\n\n/**\r\n * Get value from row using column mapping\r\n * @param {Array} row - Data row\r\n * @param {number} columnIndex - Column index\r\n * @returns {string} - Cell value or empty string\r\n */\nconst getColumnValue = (row, columnIndex) => {\n  if (columnIndex === undefined || columnIndex === null || columnIndex < 0) {\n    return '';\n  }\n  const value = row[columnIndex];\n  return value !== null && value !== undefined ? String(value).trim() : '';\n};\n\n/**\r\n * Validate student data for completeness and accuracy\r\n * @param {Array} students - Array of student objects\r\n * @returns {Object} - Validation results with statistics and issues\r\n */\nexport const validateStudentData = students => {\n  const validation = {\n    totalStudents: students.length,\n    validStudents: 0,\n    issues: [],\n    completeness: {\n      withId: 0,\n      withName: 0,\n      withEmail: 0,\n      withProgram: 0,\n      withLevel: 0,\n      withCampus: 0,\n      withStatus: 0\n    },\n    duplicateIds: [],\n    invalidEmails: [],\n    missingRequiredFields: []\n  };\n  const seenIds = new Set();\n  students.forEach((student, index) => {\n    let isValid = true;\n\n    // Check required fields\n    if (!student.id || student.id.trim() === '') {\n      validation.issues.push(`Row ${index + 1}: Missing student ID`);\n      validation.missingRequiredFields.push({\n        row: index + 1,\n        field: 'id',\n        student: student.name || 'Unknown'\n      });\n      isValid = false;\n    } else {\n      validation.completeness.withId++;\n\n      // Check for duplicate IDs\n      if (seenIds.has(student.id)) {\n        validation.duplicateIds.push({\n          id: student.id,\n          rows: [index + 1] // Could track multiple occurrences\n        });\n        validation.issues.push(`Row ${index + 1}: Duplicate student ID ${student.id}`);\n        isValid = false;\n      } else {\n        seenIds.add(student.id);\n      }\n    }\n    if (!student.name || student.name.trim() === '') {\n      validation.issues.push(`Row ${index + 1}: Missing student name`);\n      validation.missingRequiredFields.push({\n        row: index + 1,\n        field: 'name',\n        student: student.id || 'Unknown'\n      });\n      isValid = false;\n    } else {\n      validation.completeness.withName++;\n    }\n\n    // Check optional fields for completeness tracking\n    if (student.email && student.email.trim() !== '') {\n      validation.completeness.withEmail++;\n\n      // Basic email validation\n      const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n      if (!emailRegex.test(student.email)) {\n        validation.invalidEmails.push({\n          row: index + 1,\n          email: student.email,\n          student: student.name || student.id\n        });\n        validation.issues.push(`Row ${index + 1}: Invalid email format: ${student.email}`);\n      }\n    }\n    if (student.program && student.program.trim() !== '') {\n      validation.completeness.withProgram++;\n    }\n    if (student.level && student.level.trim() !== '') {\n      validation.completeness.withLevel++;\n    }\n    if (student.campus && student.campus.trim() !== '') {\n      validation.completeness.withCampus++;\n    }\n    if (student.status && student.status.trim() !== '') {\n      validation.completeness.withStatus++;\n    }\n    if (isValid) {\n      validation.validStudents++;\n    }\n  });\n\n  // Calculate completeness percentages\n  const total = students.length;\n  validation.completenessPercentages = {\n    id: total > 0 ? (validation.completeness.withId / total * 100).toFixed(1) : 0,\n    name: total > 0 ? (validation.completeness.withName / total * 100).toFixed(1) : 0,\n    email: total > 0 ? (validation.completeness.withEmail / total * 100).toFixed(1) : 0,\n    program: total > 0 ? (validation.completeness.withProgram / total * 100).toFixed(1) : 0,\n    level: total > 0 ? (validation.completeness.withLevel / total * 100).toFixed(1) : 0,\n    campus: total > 0 ? (validation.completeness.withCampus / total * 100).toFixed(1) : 0,\n    status: total > 0 ? (validation.completeness.withStatus / total * 100).toFixed(1) : 0\n  };\n\n  // Overall validation status\n  validation.isValid = validation.validStudents === validation.totalStudents;\n  validation.validationScore = total > 0 ? (validation.validStudents / total * 100).toFixed(1) : 0;\n  return validation;\n};","map":{"version":3,"names":["XLSX","parseExcelFile","file","console","log","name","arrayBuffer","workbook","read","type","firstSheetName","SheetNames","worksheet","Sheets","rawData","utils","sheet_to_json","header","defval","blankrows","length","slice","tableInfo","findStudentDataTable","found","Error","headers","headerRow","dataRows","dataStartRow","dataEndRow","students","parseStudentData","totalRows","success","message","error","suggestions","rowIndex","Math","min","row","hasStudentIDs","some","cell","cellStr","String","trim","test","findHeaderRow","findDataEndRow","firstStudentRow","studentsFound","headerScore","calculateHeaderScore","studentRowIndex","i","max","startRow","lastDataRow","rowText","join","toLowerCase","includes","nonEmptyCells","filter","undefined","score","rowStr","headerPatterns","id","email","program","level","status","campus","forEach","Object","values","patterns","pattern","columnMap","mapColumns","index","student","getColumnValue","component","originalRow","push","mapping","headerStr","entries","key","patternList","match","columnIndex","value","validateStudentData","validation","totalStudents","validStudents","issues","completeness","withId","withName","withEmail","withProgram","withLevel","withCampus","withStatus","duplicateIds","invalidEmails","missingRequiredFields","seenIds","Set","isValid","field","has","rows","add","emailRegex","total","completenessPercentages","toFixed","validationScore"],"sources":["C:/local clones/rubric-creation-app/src/utils/excelParser.js"],"sourcesContent":["// Enhanced excelParser.js - Fixed version with proper table detection\r\nimport * as XLSX from 'xlsx';\r\n\r\n/**\r\n * Parse Excel file and extract student data with enhanced table detection\r\n * @param {File} file - Excel file to parse\r\n * @returns {Promise<Object>} - Parsed data with students array and metadata\r\n */\r\nexport const parseExcelFile = async (file) => {\r\n    try {\r\n        console.log('üîç Starting Excel file parsing:', file.name);\r\n\r\n        const arrayBuffer = await file.arrayBuffer();\r\n        const workbook = XLSX.read(arrayBuffer, { type: 'array' });\r\n        const firstSheetName = workbook.SheetNames[0];\r\n        const worksheet = workbook.Sheets[firstSheetName];\r\n\r\n        console.log('üìä Workbook sheets:', workbook.SheetNames);\r\n\r\n        // Convert to array of arrays for easier processing\r\n        const rawData = XLSX.utils.sheet_to_json(worksheet, {\r\n            header: 1,\r\n            defval: '',\r\n            blankrows: false\r\n        });\r\n\r\n        console.log(`üìã Total rows in Excel: ${rawData.length}`);\r\n        console.log('üîç First 15 rows for debugging:', rawData.slice(0, 15));\r\n\r\n        // Enhanced table detection\r\n        const tableInfo = findStudentDataTable(rawData);\r\n\r\n        if (!tableInfo.found) {\r\n            throw new Error('Could not locate student data table in Excel file');\r\n        }\r\n\r\n        console.log(`‚úÖ Student data table found:`, tableInfo);\r\n\r\n        // Extract headers and data\r\n        const headers = rawData[tableInfo.headerRow];\r\n        const dataRows = rawData.slice(tableInfo.dataStartRow, tableInfo.dataEndRow + 1);\r\n\r\n        console.log('üìë Detected headers:', headers);\r\n        console.log(`üìä Data rows to process: ${dataRows.length}`);\r\n\r\n        // Parse student data with enhanced mapping\r\n        const students = parseStudentData(headers, dataRows);\r\n\r\n        console.log(`üéì Successfully parsed ${students.length} students`);\r\n\r\n        return {\r\n            students,\r\n            totalRows: rawData.length,\r\n            dataRows: dataRows.length,\r\n            headers,\r\n            tableInfo,\r\n            success: true,\r\n            message: `Successfully parsed ${students.length} students from ${dataRows.length} data rows`\r\n        };\r\n\r\n    } catch (error) {\r\n        console.error('‚ùå Excel parsing error:', error);\r\n        return {\r\n            students: [],\r\n            success: false,\r\n            error: error.message,\r\n            suggestions: [\r\n                'Ensure the Excel file contains a student data table',\r\n                'Check that student IDs are in 6-digit format (e.g., 400001)',\r\n                'Verify column headers include ID, Name, Email, etc.',\r\n                'Make sure the file is not corrupted or password protected'\r\n            ]\r\n        };\r\n    }\r\n};\r\n\r\n/**\r\n * Enhanced function to find the actual student data table within the Excel file\r\n * @param {Array} rawData - Raw Excel data as array of arrays\r\n * @returns {Object} - Table location information\r\n */\r\nconst findStudentDataTable = (rawData) => {\r\n    console.log('üîç Searching for student data table...');\r\n\r\n    // Look for student ID patterns and data table indicators\r\n    for (let rowIndex = 0; rowIndex < Math.min(rawData.length, 30); rowIndex++) {\r\n        const row = rawData[rowIndex];\r\n\r\n        if (!row || row.length === 0) continue;\r\n\r\n        // Check if this row contains student ID patterns (6-digit numbers starting with 4)\r\n        const hasStudentIDs = row.some(cell => {\r\n            const cellStr = String(cell).trim();\r\n            return /^4\\d{5}$/.test(cellStr); // Matches 400001, 400002, etc.\r\n        });\r\n\r\n        if (hasStudentIDs) {\r\n            console.log(`üéØ Found student IDs in row ${rowIndex}:`, row);\r\n\r\n            // Look backwards for the header row\r\n            const headerRow = findHeaderRow(rawData, rowIndex);\r\n\r\n            if (headerRow !== -1) {\r\n                // Find the end of data table\r\n                const dataEndRow = findDataEndRow(rawData, rowIndex);\r\n\r\n                return {\r\n                    found: true,\r\n                    headerRow,\r\n                    dataStartRow: rowIndex,\r\n                    dataEndRow,\r\n                    firstStudentRow: rowIndex,\r\n                    studentsFound: dataEndRow - rowIndex + 1\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    // Fallback: Look for institutional header patterns\r\n    for (let rowIndex = 0; rowIndex < Math.min(rawData.length, 25); rowIndex++) {\r\n        const row = rawData[rowIndex];\r\n\r\n        if (!row || row.length < 5) continue;\r\n\r\n        // Check for institutional column header patterns\r\n        const headerScore = calculateHeaderScore(row);\r\n\r\n        if (headerScore >= 3) { // Need at least 3 matching column patterns\r\n            console.log(`üìã Found potential headers in row ${rowIndex}:`, row);\r\n\r\n            // Look for data rows following this header\r\n            const dataStartRow = rowIndex + 1;\r\n            const dataEndRow = findDataEndRow(rawData, dataStartRow);\r\n\r\n            if (dataEndRow > dataStartRow) {\r\n                return {\r\n                    found: true,\r\n                    headerRow: rowIndex,\r\n                    dataStartRow,\r\n                    dataEndRow,\r\n                    studentsFound: dataEndRow - dataStartRow + 1\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    return { found: false };\r\n};\r\n\r\n/**\r\n * Find the header row by looking backwards from a student data row\r\n * @param {Array} rawData - Raw Excel data\r\n * @param {number} studentRowIndex - Index of row containing student data\r\n * @returns {number} - Header row index or -1 if not found\r\n */\r\nconst findHeaderRow = (rawData, studentRowIndex) => {\r\n    // Look up to 5 rows back for headers\r\n    for (let i = Math.max(0, studentRowIndex - 5); i < studentRowIndex; i++) {\r\n        const row = rawData[i];\r\n\r\n        if (!row || row.length === 0) continue;\r\n\r\n        const headerScore = calculateHeaderScore(row);\r\n\r\n        if (headerScore >= 3) {\r\n            console.log(`üìã Found header row ${i} with score ${headerScore}:`, row);\r\n            return i;\r\n        }\r\n    }\r\n\r\n    // If no clear headers found, assume the row immediately before student data\r\n    return Math.max(0, studentRowIndex - 1);\r\n};\r\n\r\n/**\r\n * Find the end of the data table\r\n * @param {Array} rawData - Raw Excel data\r\n * @param {number} startRow - Starting row index\r\n * @returns {number} - Last row index with data\r\n */\r\nconst findDataEndRow = (rawData, startRow) => {\r\n    let lastDataRow = startRow;\r\n\r\n    for (let i = startRow; i < rawData.length; i++) {\r\n        const row = rawData[i];\r\n\r\n        // Stop if we hit an empty row or summary information\r\n        if (!row || row.length === 0) break;\r\n\r\n        // Stop if we hit administrative text like \"Total Students:\" or \"Signature\"\r\n        const rowText = row.join(' ').toLowerCase();\r\n        if (rowText.includes('total') ||\r\n            rowText.includes('signature') ||\r\n            rowText.includes('professor') ||\r\n            rowText.includes('page ')) {\r\n            break;\r\n        }\r\n\r\n        // Continue if row has substantial data (at least 3 non-empty cells)\r\n        const nonEmptyCells = row.filter(cell =>\r\n            cell !== null && cell !== undefined && String(cell).trim() !== ''\r\n        ).length;\r\n\r\n        if (nonEmptyCells >= 3) {\r\n            lastDataRow = i;\r\n        } else if (i > startRow + 2) {\r\n            // If we've seen some data and now have sparse rows, probably end of table\r\n            break;\r\n        }\r\n    }\r\n\r\n    return lastDataRow;\r\n};\r\n\r\n/**\r\n * Calculate how likely a row is to contain column headers\r\n * @param {Array} row - Row data\r\n * @returns {number} - Score (0-7) indicating likelihood of being headers\r\n */\r\nconst calculateHeaderScore = (row) => {\r\n    let score = 0;\r\n    const rowStr = row.join(' ').toLowerCase();\r\n\r\n    // Institutional header patterns with flexible matching\r\n    const headerPatterns = {\r\n        id: ['component', 'id', 'student id', 'studentid', 'number'],\r\n        name: ['name', 'student name', 'full name', 'student'],\r\n        email: ['email', 'e-mail', 'student email', 'emailaddress'],\r\n        program: ['program', 'course', 'programcode', 'coursecode'],\r\n        level: ['level', 'year', 'semester', 'term', 'grade'],\r\n        status: ['status', 'enrollment', 'active', 'enrolled'],\r\n        campus: ['campus', 'location', 'site']\r\n    };\r\n\r\n    // Check each cell for header patterns\r\n    row.forEach(cell => {\r\n        const cellStr = String(cell).trim().toLowerCase();\r\n\r\n        if (cellStr.length === 0) return;\r\n\r\n        // Check against all pattern categories\r\n        Object.values(headerPatterns).forEach(patterns => {\r\n            if (patterns.some(pattern =>\r\n                cellStr.includes(pattern) || pattern.includes(cellStr)\r\n            )) {\r\n                score++;\r\n            }\r\n        });\r\n    });\r\n\r\n    console.log(`üìä Header score for row: ${score}`, row);\r\n    return score;\r\n};\r\n\r\n/**\r\n * Enhanced student data parsing with better column mapping\r\n * @param {Array} headers - Column headers\r\n * @param {Array} dataRows - Data rows to parse\r\n * @returns {Array} - Array of student objects\r\n */\r\nconst parseStudentData = (headers, dataRows) => {\r\n    console.log('üîÑ Parsing student data with headers:', headers);\r\n\r\n    // Enhanced column mapping\r\n    const columnMap = mapColumns(headers);\r\n    console.log('üìç Column mapping:', columnMap);\r\n\r\n    const students = [];\r\n\r\n    dataRows.forEach((row, index) => {\r\n        try {\r\n            // Skip empty rows\r\n            if (!row || row.length === 0) return;\r\n\r\n            // Extract student data using column mapping\r\n            const student = {\r\n                id: getColumnValue(row, columnMap.id),\r\n                name: getColumnValue(row, columnMap.name),\r\n                email: getColumnValue(row, columnMap.email),\r\n                program: getColumnValue(row, columnMap.program),\r\n                level: getColumnValue(row, columnMap.level),\r\n                campus: getColumnValue(row, columnMap.campus),\r\n                status: getColumnValue(row, columnMap.status),\r\n                component: getColumnValue(row, columnMap.component),\r\n                originalRow: index,\r\n                rawData: row\r\n            };\r\n\r\n            // Validate student data - require at least ID and name\r\n            if (student.id && student.name &&\r\n                String(student.id).trim() !== '' &&\r\n                String(student.name).trim() !== '') {\r\n\r\n                // Clean up data\r\n                student.id = String(student.id).trim();\r\n                student.name = String(student.name).trim();\r\n                student.email = String(student.email || '').trim();\r\n                student.program = String(student.program || '').trim();\r\n                student.level = String(student.level || '').trim();\r\n                student.campus = String(student.campus || '').trim();\r\n                student.status = String(student.status || '').trim();\r\n\r\n                students.push(student);\r\n                console.log(`‚úÖ Parsed student ${students.length}:`, student);\r\n            } else {\r\n                console.log(`‚ö†Ô∏è Skipping invalid row ${index}:`, student);\r\n            }\r\n\r\n        } catch (error) {\r\n            console.error(`‚ùå Error parsing row ${index}:`, error, row);\r\n        }\r\n    });\r\n\r\n    return students;\r\n};\r\n\r\n/**\r\n * Enhanced column mapping with institutional patterns\r\n * @param {Array} headers - Header row\r\n * @returns {Object} - Column index mapping\r\n */\r\nconst mapColumns = (headers) => {\r\n    const mapping = {};\r\n\r\n    // Enhanced patterns for institutional Excel files\r\n    const patterns = {\r\n        component: ['component', 'session', 'section', 'class'],\r\n        id: ['id', 'student id', 'studentid', 'number', 'student number'],\r\n        name: ['name', 'student name', 'full name', 'student'],\r\n        email: ['email', 'e-mail', 'student email', 'emailaddress'],\r\n        program: ['program', 'course', 'programcode', 'coursecode', 'course code'],\r\n        level: ['level', 'year', 'semester', 'term', 'grade'],\r\n        campus: ['campus', 'location', 'site'],\r\n        status: ['status', 'enrollment', 'active', 'enrolled', 'standing']\r\n    };\r\n\r\n    // Map each header to a column type\r\n    headers.forEach((header, index) => {\r\n        const headerStr = String(header).trim().toLowerCase();\r\n\r\n        if (headerStr.length === 0) return;\r\n\r\n        // Check against each pattern category\r\n        Object.entries(patterns).forEach(([key, patternList]) => {\r\n            if (!mapping[key]) { // Only assign if not already mapped\r\n                const match = patternList.some(pattern =>\r\n                    headerStr.includes(pattern) || pattern.includes(headerStr)\r\n                );\r\n\r\n                if (match) {\r\n                    mapping[key] = index;\r\n                    console.log(`üìç Mapped \"${header}\" (index ${index}) to ${key}`);\r\n                }\r\n            }\r\n        });\r\n    });\r\n\r\n    return mapping;\r\n};\r\n\r\n/**\r\n * Get value from row using column mapping\r\n * @param {Array} row - Data row\r\n * @param {number} columnIndex - Column index\r\n * @returns {string} - Cell value or empty string\r\n */\r\nconst getColumnValue = (row, columnIndex) => {\r\n    if (columnIndex === undefined || columnIndex === null || columnIndex < 0) {\r\n        return '';\r\n    }\r\n\r\n    const value = row[columnIndex];\r\n    return value !== null && value !== undefined ? String(value).trim() : '';\r\n};\r\n\r\n/**\r\n * Validate student data for completeness and accuracy\r\n * @param {Array} students - Array of student objects\r\n * @returns {Object} - Validation results with statistics and issues\r\n */\r\nexport const validateStudentData = (students) => {\r\n    const validation = {\r\n        totalStudents: students.length,\r\n        validStudents: 0,\r\n        issues: [],\r\n        completeness: {\r\n            withId: 0,\r\n            withName: 0,\r\n            withEmail: 0,\r\n            withProgram: 0,\r\n            withLevel: 0,\r\n            withCampus: 0,\r\n            withStatus: 0\r\n        },\r\n        duplicateIds: [],\r\n        invalidEmails: [],\r\n        missingRequiredFields: []\r\n    };\r\n\r\n    const seenIds = new Set();\r\n\r\n    students.forEach((student, index) => {\r\n        let isValid = true;\r\n\r\n        // Check required fields\r\n        if (!student.id || student.id.trim() === '') {\r\n            validation.issues.push(`Row ${index + 1}: Missing student ID`);\r\n            validation.missingRequiredFields.push({\r\n                row: index + 1,\r\n                field: 'id',\r\n                student: student.name || 'Unknown'\r\n            });\r\n            isValid = false;\r\n        } else {\r\n            validation.completeness.withId++;\r\n\r\n            // Check for duplicate IDs\r\n            if (seenIds.has(student.id)) {\r\n                validation.duplicateIds.push({\r\n                    id: student.id,\r\n                    rows: [index + 1] // Could track multiple occurrences\r\n                });\r\n                validation.issues.push(`Row ${index + 1}: Duplicate student ID ${student.id}`);\r\n                isValid = false;\r\n            } else {\r\n                seenIds.add(student.id);\r\n            }\r\n        }\r\n\r\n        if (!student.name || student.name.trim() === '') {\r\n            validation.issues.push(`Row ${index + 1}: Missing student name`);\r\n            validation.missingRequiredFields.push({\r\n                row: index + 1,\r\n                field: 'name',\r\n                student: student.id || 'Unknown'\r\n            });\r\n            isValid = false;\r\n        } else {\r\n            validation.completeness.withName++;\r\n        }\r\n\r\n        // Check optional fields for completeness tracking\r\n        if (student.email && student.email.trim() !== '') {\r\n            validation.completeness.withEmail++;\r\n\r\n            // Basic email validation\r\n            const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n            if (!emailRegex.test(student.email)) {\r\n                validation.invalidEmails.push({\r\n                    row: index + 1,\r\n                    email: student.email,\r\n                    student: student.name || student.id\r\n                });\r\n                validation.issues.push(`Row ${index + 1}: Invalid email format: ${student.email}`);\r\n            }\r\n        }\r\n\r\n        if (student.program && student.program.trim() !== '') {\r\n            validation.completeness.withProgram++;\r\n        }\r\n\r\n        if (student.level && student.level.trim() !== '') {\r\n            validation.completeness.withLevel++;\r\n        }\r\n\r\n        if (student.campus && student.campus.trim() !== '') {\r\n            validation.completeness.withCampus++;\r\n        }\r\n\r\n        if (student.status && student.status.trim() !== '') {\r\n            validation.completeness.withStatus++;\r\n        }\r\n\r\n        if (isValid) {\r\n            validation.validStudents++;\r\n        }\r\n    });\r\n\r\n    // Calculate completeness percentages\r\n    const total = students.length;\r\n    validation.completenessPercentages = {\r\n        id: total > 0 ? (validation.completeness.withId / total * 100).toFixed(1) : 0,\r\n        name: total > 0 ? (validation.completeness.withName / total * 100).toFixed(1) : 0,\r\n        email: total > 0 ? (validation.completeness.withEmail / total * 100).toFixed(1) : 0,\r\n        program: total > 0 ? (validation.completeness.withProgram / total * 100).toFixed(1) : 0,\r\n        level: total > 0 ? (validation.completeness.withLevel / total * 100).toFixed(1) : 0,\r\n        campus: total > 0 ? (validation.completeness.withCampus / total * 100).toFixed(1) : 0,\r\n        status: total > 0 ? (validation.completeness.withStatus / total * 100).toFixed(1) : 0\r\n    };\r\n\r\n    // Overall validation status\r\n    validation.isValid = validation.validStudents === validation.totalStudents;\r\n    validation.validationScore = total > 0 ? (validation.validStudents / total * 100).toFixed(1) : 0;\r\n\r\n    return validation;\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}