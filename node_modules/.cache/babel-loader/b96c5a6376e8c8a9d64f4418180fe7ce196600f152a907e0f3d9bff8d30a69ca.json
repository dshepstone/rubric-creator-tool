{"ast":null,"code":"// utils/excelParser.js\nimport * as XLSX from 'xlsx';\nexport const parseExcelFile = async file => {\n  try {\n    const buf = await file.arrayBuffer();\n    const wb = XLSX.read(buf, {\n      type: 'array'\n    });\n    const sheetName = wb.SheetNames[0];\n    const ws = wb.Sheets[sheetName];\n    const raw = XLSX.utils.sheet_to_json(ws, {\n      header: 1,\n      defval: '',\n      blankrows: false\n    });\n\n    // 1) Locate header row by “ID, Name, Email, Program, Level, Campus, Status”\n    const tableInfo = findStudentDataTable(raw);\n    if (!tableInfo.found) {\n      throw new Error('Couldn’t detect the student table headers in your Excel.');\n    }\n\n    // 2) Extract student rows\n    const headers = raw[tableInfo.headerRow];\n    const rows = raw.slice(tableInfo.dataStartRow, tableInfo.dataEndRow + 1);\n    const students = parseStudentData(headers, rows);\n\n    // 3) Pull course-level metadata\n    const courseMetadata = extractCourseMetadata(raw, students);\n    return {\n      success: true,\n      students,\n      validation: null,\n      // React component will fill this in\n      courseMetadata,\n      totalRows: raw.length,\n      dataRows: rows.length,\n      headers,\n      tableInfo,\n      message: `Parsed ${students.length} students from ${rows.length} rows.`\n    };\n  } catch (err) {\n    return {\n      success: false,\n      error: err.message,\n      students: [],\n      suggestions: ['Verify the sheet has a “Component, ID, Name…” header row.', 'Check that student IDs are in their own column under “ID.”', 'Ensure no extra blank rows between your header and data.']\n    };\n  }\n};\n\n/** --- Helpers below --- **/\n\n// 1) Find the header row by scoring each row for known column names\nconst findStudentDataTable = data => {\n  const isHeader = r => {\n    const text = r.map(c => String(c).toLowerCase()).join(' ');\n    return ['component', 'id', 'name', 'email', 'program', 'level', 'campus', 'status'].filter(t => text.includes(t)).length >= 4;\n  };\n  for (let i = 0; i < data.length; i++) {\n    if (isHeader(data[i])) {\n      const start = i + 1;\n      const end = findDataEndRow(data, start);\n      if (end >= start) {\n        return {\n          found: true,\n          headerRow: i,\n          dataStartRow: start,\n          dataEndRow: end\n        };\n      }\n    }\n  }\n  return {\n    found: false\n  };\n};\n\n// 2) Stop when you hit a mostly blank or summary row\nconst findDataEndRow = (data, start) => {\n  let last = start;\n  for (let i = start; i < data.length; i++) {\n    const row = data[i].filter(c => String(c).trim() !== '');\n    if (row.length < 3) break;\n    last = i;\n  }\n  return last;\n};\n\n// 3) Map headers → student object\nconst parseStudentData = (hdrs, rows) => {\n  const idx = {};\n  hdrs.forEach((h, i) => {\n    const t = String(h).toLowerCase();\n    if (t.includes('component')) idx.component = i;\n    if (t === 'id' || t.includes('student id')) idx.id = i;\n    if (t.includes('name')) idx.name = i;\n    if (t.includes('email')) idx.email = i;\n    if (t.includes('program')) idx.program = i;\n    if (t.includes('level')) idx.level = i;\n    if (t.includes('campus')) idx.campus = i;\n    if (t.includes('status')) idx.status = i;\n  });\n  return rows.map(r => ({\n    component: String(r[idx.component] || '').trim(),\n    id: String(r[idx.id] || '').trim(),\n    name: String(r[idx.name] || '').trim(),\n    email: String(r[idx.email] || '').trim(),\n    program: String(r[idx.program] || '').trim(),\n    level: String(r[idx.level] || '').trim(),\n    campus: String(r[idx.campus] || '').trim(),\n    status: String(r[idx.status] || '').trim()\n  })).filter(s => s.id && s.name); // drop totally blank rows\n};\n\n// 4) Scan the first 15 rows for your key metadata\nconst extractCourseMetadata = (raw, students) => {\n  const md = {\n    courseCode: '',\n    courseName: '',\n    section: '',\n    campus: '',\n    professors: '',\n    term: '',\n    hours: '',\n    gradeScale: '',\n    department: '',\n    totalStudents: students.length\n  };\n  for (let i = 0; i < Math.min(raw.length, 15); i++) {\n    const row = raw[i].map(c => String(c).trim());\n    const line = row.join(' ');\n\n    // Term: “Spring 2025”\n    const termMatch = line.match(/\\b(Fall|Winter|Spring|Summer)\\s+(\\d{4})\\b/);\n    if (termMatch) md.term = `${termMatch[1]} ${termMatch[2]}`;\n\n    // Code + Name + Section + Campus: row like “DSGN8060 – Animation Methodologies II (100) Section 1 – Doon”\n    if (!md.courseCode && row[0].match(/^([A-Z0-9]+)\\s*[-–]/)) {\n      const parts = row[0].split(/[-–]/).map(p => p.trim());\n      md.courseCode = parts[0];\n      let rest = parts.slice(1).join(' - ');\n      // strip parenthesis\n      rest = rest.replace(/\\(.*?\\)/g, '').trim();\n      // Section\n      const sec = rest.match(/Section\\s+(\\w+)/i);\n      if (sec) md.section = `Section ${sec[1]}`;\n      // Campus\n      const cam = rest.match(/[-–]\\s*(\\w+)\\s*$/);\n      if (cam) md.campus = `${cam[1]} Campus`;\n      // Base name = before “Section”\n      md.courseName = rest.split(/Section/i)[0].trim();\n    }\n\n    // Professors:\n    const profIdx = row.findIndex(c => /Professors?:/i.test(c));\n    if (profIdx > -1) {\n      const nameCell = row.slice(profIdx + 1).find(c => c);\n      if (nameCell) md.professors = nameCell;\n    }\n\n    // Hours:\n    const hrIdx = row.findIndex(c => /Hours:/i.test(c));\n    if (hrIdx > -1) {\n      const num = row[hrIdx + 1] || '';\n      md.hours = String(num).trim();\n    }\n\n    // Grade Scale:\n    const gsIdx = row.findIndex(c => /Grade Scale:/i.test(c));\n    if (gsIdx > -1) {\n      md.gradeScale = row[gsIdx + 1] || '';\n    }\n\n    // Department:\n    const dIdx = row.findIndex(c => /Delivery\\s+Dept:/i.test(c) || /^Dept:/i.test(c));\n    if (dIdx > -1) {\n      md.department = row[dIdx + 1] || '';\n    }\n  }\n  return md;\n};","map":{"version":3,"names":["XLSX","parseExcelFile","file","buf","arrayBuffer","wb","read","type","sheetName","SheetNames","ws","Sheets","raw","utils","sheet_to_json","header","defval","blankrows","tableInfo","findStudentDataTable","found","Error","headers","headerRow","rows","slice","dataStartRow","dataEndRow","students","parseStudentData","courseMetadata","extractCourseMetadata","success","validation","totalRows","length","dataRows","message","err","error","suggestions","data","isHeader","r","text","map","c","String","toLowerCase","join","filter","t","includes","i","start","end","findDataEndRow","last","row","trim","hdrs","idx","forEach","h","component","id","name","email","program","level","campus","status","s","md","courseCode","courseName","section","professors","term","hours","gradeScale","department","totalStudents","Math","min","line","termMatch","match","parts","split","p","rest","replace","sec","cam","profIdx","findIndex","test","nameCell","find","hrIdx","num","gsIdx","dIdx"],"sources":["C:/local clones/rubric-creation-app/src/utils/excelParser.js"],"sourcesContent":["// utils/excelParser.js\r\nimport * as XLSX from 'xlsx';\r\n\r\nexport const parseExcelFile = async (file) => {\r\n    try {\r\n        const buf = await file.arrayBuffer();\r\n        const wb = XLSX.read(buf, { type: 'array' });\r\n        const sheetName = wb.SheetNames[0];\r\n        const ws = wb.Sheets[sheetName];\r\n        const raw = XLSX.utils.sheet_to_json(ws, { header: 1, defval: '', blankrows: false });\r\n\r\n        // 1) Locate header row by “ID, Name, Email, Program, Level, Campus, Status”\r\n        const tableInfo = findStudentDataTable(raw);\r\n        if (!tableInfo.found) {\r\n            throw new Error('Couldn’t detect the student table headers in your Excel.');\r\n        }\r\n\r\n        // 2) Extract student rows\r\n        const headers = raw[tableInfo.headerRow];\r\n        const rows = raw.slice(tableInfo.dataStartRow, tableInfo.dataEndRow + 1);\r\n        const students = parseStudentData(headers, rows);\r\n\r\n        // 3) Pull course-level metadata\r\n        const courseMetadata = extractCourseMetadata(raw, students);\r\n\r\n        return {\r\n            success: true,\r\n            students,\r\n            validation: null,             // React component will fill this in\r\n            courseMetadata,\r\n            totalRows: raw.length,\r\n            dataRows: rows.length,\r\n            headers,\r\n            tableInfo,\r\n            message: `Parsed ${students.length} students from ${rows.length} rows.`\r\n        };\r\n\r\n    } catch (err) {\r\n        return {\r\n            success: false,\r\n            error: err.message,\r\n            students: [],\r\n            suggestions: [\r\n                'Verify the sheet has a “Component, ID, Name…” header row.',\r\n                'Check that student IDs are in their own column under “ID.”',\r\n                'Ensure no extra blank rows between your header and data.'\r\n            ]\r\n        };\r\n    }\r\n};\r\n\r\n/** --- Helpers below --- **/\r\n\r\n// 1) Find the header row by scoring each row for known column names\r\nconst findStudentDataTable = (data) => {\r\n    const isHeader = (r) => {\r\n        const text = r.map(c => String(c).toLowerCase()).join(' ');\r\n        return ['component', 'id', 'name', 'email', 'program', 'level', 'campus', 'status']\r\n            .filter(t => text.includes(t)).length >= 4;\r\n    };\r\n\r\n    for (let i = 0; i < data.length; i++) {\r\n        if (isHeader(data[i])) {\r\n            const start = i + 1;\r\n            const end = findDataEndRow(data, start);\r\n            if (end >= start) {\r\n                return { found: true, headerRow: i, dataStartRow: start, dataEndRow: end };\r\n            }\r\n        }\r\n    }\r\n    return { found: false };\r\n};\r\n\r\n// 2) Stop when you hit a mostly blank or summary row\r\nconst findDataEndRow = (data, start) => {\r\n    let last = start;\r\n    for (let i = start; i < data.length; i++) {\r\n        const row = data[i].filter(c => String(c).trim() !== '');\r\n        if (row.length < 3) break;\r\n        last = i;\r\n    }\r\n    return last;\r\n};\r\n\r\n// 3) Map headers → student object\r\nconst parseStudentData = (hdrs, rows) => {\r\n    const idx = {};\r\n    hdrs.forEach((h, i) => {\r\n        const t = String(h).toLowerCase();\r\n        if (t.includes('component')) idx.component = i;\r\n        if (t === 'id' || t.includes('student id')) idx.id = i;\r\n        if (t.includes('name')) idx.name = i;\r\n        if (t.includes('email')) idx.email = i;\r\n        if (t.includes('program')) idx.program = i;\r\n        if (t.includes('level')) idx.level = i;\r\n        if (t.includes('campus')) idx.campus = i;\r\n        if (t.includes('status')) idx.status = i;\r\n    });\r\n\r\n    return rows.map(r => ({\r\n        component: String(r[idx.component] || '').trim(),\r\n        id: String(r[idx.id] || '').trim(),\r\n        name: String(r[idx.name] || '').trim(),\r\n        email: String(r[idx.email] || '').trim(),\r\n        program: String(r[idx.program] || '').trim(),\r\n        level: String(r[idx.level] || '').trim(),\r\n        campus: String(r[idx.campus] || '').trim(),\r\n        status: String(r[idx.status] || '').trim(),\r\n    }))\r\n        .filter(s => s.id && s.name); // drop totally blank rows\r\n};\r\n\r\n// 4) Scan the first 15 rows for your key metadata\r\nconst extractCourseMetadata = (raw, students) => {\r\n    const md = {\r\n        courseCode: '',\r\n        courseName: '',\r\n        section: '',\r\n        campus: '',\r\n        professors: '',\r\n        term: '',\r\n        hours: '',\r\n        gradeScale: '',\r\n        department: '',\r\n        totalStudents: students.length\r\n    };\r\n\r\n    for (let i = 0; i < Math.min(raw.length, 15); i++) {\r\n        const row = raw[i].map(c => String(c).trim());\r\n        const line = row.join(' ');\r\n\r\n        // Term: “Spring 2025”\r\n        const termMatch = line.match(/\\b(Fall|Winter|Spring|Summer)\\s+(\\d{4})\\b/);\r\n        if (termMatch) md.term = `${termMatch[1]} ${termMatch[2]}`;\r\n\r\n        // Code + Name + Section + Campus: row like “DSGN8060 – Animation Methodologies II (100) Section 1 – Doon”\r\n        if (!md.courseCode && row[0].match(/^([A-Z0-9]+)\\s*[-–]/)) {\r\n            const parts = row[0].split(/[-–]/).map(p => p.trim());\r\n            md.courseCode = parts[0];\r\n            let rest = parts.slice(1).join(' - ');\r\n            // strip parenthesis\r\n            rest = rest.replace(/\\(.*?\\)/g, '').trim();\r\n            // Section\r\n            const sec = rest.match(/Section\\s+(\\w+)/i);\r\n            if (sec) md.section = `Section ${sec[1]}`;\r\n            // Campus\r\n            const cam = rest.match(/[-–]\\s*(\\w+)\\s*$/);\r\n            if (cam) md.campus = `${cam[1]} Campus`;\r\n            // Base name = before “Section”\r\n            md.courseName = rest.split(/Section/i)[0].trim();\r\n        }\r\n\r\n        // Professors:\r\n        const profIdx = row.findIndex(c => /Professors?:/i.test(c));\r\n        if (profIdx > -1) {\r\n            const nameCell = row.slice(profIdx + 1).find(c => c);\r\n            if (nameCell) md.professors = nameCell;\r\n        }\r\n\r\n        // Hours:\r\n        const hrIdx = row.findIndex(c => /Hours:/i.test(c));\r\n        if (hrIdx > -1) {\r\n            const num = row[hrIdx + 1] || '';\r\n            md.hours = String(num).trim();\r\n        }\r\n\r\n        // Grade Scale:\r\n        const gsIdx = row.findIndex(c => /Grade Scale:/i.test(c));\r\n        if (gsIdx > -1) {\r\n            md.gradeScale = row[gsIdx + 1] || '';\r\n        }\r\n\r\n        // Department:\r\n        const dIdx = row.findIndex(c => /Delivery\\s+Dept:/i.test(c) || /^Dept:/i.test(c));\r\n        if (dIdx > -1) {\r\n            md.department = row[dIdx + 1] || '';\r\n        }\r\n    }\r\n\r\n    return md;\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}