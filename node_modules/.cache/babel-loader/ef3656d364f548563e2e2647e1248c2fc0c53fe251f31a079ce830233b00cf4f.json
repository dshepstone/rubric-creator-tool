{"ast":null,"code":"import * as XLSX from 'xlsx';\nexport const parseExcelFile = async file => {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onload = e => {\n      try {\n        const data = new Uint8Array(e.target.result);\n        const workbook = XLSX.read(data, {\n          type: 'array',\n          cellDates: true,\n          cellStyles: false\n        });\n        const result = processWorkbook(workbook);\n        resolve(result);\n      } catch (error) {\n        reject(new Error(`Excel parsing failed: ${error.message}`));\n      }\n    };\n    reader.onerror = () => reject(new Error('Failed to read file'));\n    reader.readAsArrayBuffer(file);\n  });\n};\nconst processWorkbook = workbook => {\n  const sheetName = workbook.SheetNames[0];\n  const worksheet = workbook.Sheets[sheetName];\n  const jsonData = XLSX.utils.sheet_to_json(worksheet, {\n    header: 1,\n    defval: '',\n    blankrows: false\n  });\n  return parseStudentData(jsonData);\n};\nconst parseStudentData = data => {\n  if (data.length < 2) {\n    throw new Error('Excel file must contain header row and at least one student');\n  }\n  const headers = data[0].map(h => (h === null || h === void 0 ? void 0 : h.toString().toLowerCase().trim().replace(/[^a-z0-9]/g, '')) || '');\n  const columnMap = detectColumns(headers);\n  const students = [];\n  for (let i = 1; i < data.length; i++) {\n    const row = data[i];\n    if (!row || isEmptyRow(row)) continue;\n    const student = parseStudentRow(row, columnMap);\n    if (student) students.push(student);\n  }\n  return {\n    students,\n    metadata: {\n      totalRows: data.length - 1,\n      parsed: students.length,\n      columns: Object.keys(columnMap)\n    }\n  };\n};\nconst detectColumns = headers => {\n  const patterns = {\n    id: ['id', 'studentid', 'student_id', 'number', 'studentnumber'],\n    name: ['name', 'studentname', 'student_name', 'fullname', 'student'],\n    email: ['email', 'studentemail', 'student_email', 'emailaddress'],\n    program: ['program', 'course', 'programcode', 'coursecode'],\n    level: ['level', 'year', 'semester', 'term', 'grade'],\n    status: ['status', 'enrollment', 'active', 'enrolled'],\n    section: ['section', 'class', 'group']\n  };\n  const map = {};\n  Object.entries(patterns).forEach(([field, keywords]) => {\n    const index = headers.findIndex(header => keywords.some(keyword => header.includes(keyword)));\n    if (index !== -1) map[field] = index;\n  });\n  return map;\n};\nconst parseStudentRow = (row, columnMap) => {\n  var _row$columnMap$email, _row$columnMap$progra, _row$columnMap$level, _row$columnMap$status, _row$columnMap$sectio;\n  const getId = () => {\n    var _row$columnMap$id;\n    return (_row$columnMap$id = row[columnMap.id]) === null || _row$columnMap$id === void 0 ? void 0 : _row$columnMap$id.toString().trim();\n  };\n  const getName = () => {\n    var _row$columnMap$name;\n    return (_row$columnMap$name = row[columnMap.name]) === null || _row$columnMap$name === void 0 ? void 0 : _row$columnMap$name.toString().trim();\n  };\n  const id = getId();\n  const name = getName();\n  if (!id || !name) return null;\n  return {\n    id,\n    name,\n    email: ((_row$columnMap$email = row[columnMap.email]) === null || _row$columnMap$email === void 0 ? void 0 : _row$columnMap$email.toString().trim()) || '',\n    program: ((_row$columnMap$progra = row[columnMap.program]) === null || _row$columnMap$progra === void 0 ? void 0 : _row$columnMap$progra.toString().trim()) || '',\n    level: ((_row$columnMap$level = row[columnMap.level]) === null || _row$columnMap$level === void 0 ? void 0 : _row$columnMap$level.toString().trim()) || '',\n    status: ((_row$columnMap$status = row[columnMap.status]) === null || _row$columnMap$status === void 0 ? void 0 : _row$columnMap$status.toString().trim()) || 'Enrolled',\n    section: ((_row$columnMap$sectio = row[columnMap.section]) === null || _row$columnMap$sectio === void 0 ? void 0 : _row$columnMap$sectio.toString().trim()) || '',\n    metadata: {\n      importedAt: new Date().toISOString(),\n      sourceRow: row\n    }\n  };\n};\nconst isEmptyRow = row => {\n  return !row || row.every(cell => !cell || cell.toString().trim() === '');\n};","map":{"version":3,"names":["XLSX","parseExcelFile","file","Promise","resolve","reject","reader","FileReader","onload","e","data","Uint8Array","target","result","workbook","read","type","cellDates","cellStyles","processWorkbook","error","Error","message","onerror","readAsArrayBuffer","sheetName","SheetNames","worksheet","Sheets","jsonData","utils","sheet_to_json","header","defval","blankrows","parseStudentData","length","headers","map","h","toString","toLowerCase","trim","replace","columnMap","detectColumns","students","i","row","isEmptyRow","student","parseStudentRow","push","metadata","totalRows","parsed","columns","Object","keys","patterns","id","name","email","program","level","status","section","entries","forEach","field","keywords","index","findIndex","some","keyword","includes","_row$columnMap$email","_row$columnMap$progra","_row$columnMap$level","_row$columnMap$status","_row$columnMap$sectio","getId","_row$columnMap$id","getName","_row$columnMap$name","importedAt","Date","toISOString","sourceRow","every","cell"],"sources":["C:/local clones/rubric-creation-app/src/utils/excelParser.js"],"sourcesContent":["import * as XLSX from 'xlsx';\r\n\r\nexport const parseExcelFile = async (file) => {\r\n    return new Promise((resolve, reject) => {\r\n        const reader = new FileReader();\r\n\r\n        reader.onload = (e) => {\r\n            try {\r\n                const data = new Uint8Array(e.target.result);\r\n                const workbook = XLSX.read(data, {\r\n                    type: 'array',\r\n                    cellDates: true,\r\n                    cellStyles: false\r\n                });\r\n\r\n                const result = processWorkbook(workbook);\r\n                resolve(result);\r\n            } catch (error) {\r\n                reject(new Error(`Excel parsing failed: ${error.message}`));\r\n            }\r\n        };\r\n\r\n        reader.onerror = () => reject(new Error('Failed to read file'));\r\n        reader.readAsArrayBuffer(file);\r\n    });\r\n};\r\n\r\nconst processWorkbook = (workbook) => {\r\n    const sheetName = workbook.SheetNames[0];\r\n    const worksheet = workbook.Sheets[sheetName];\r\n\r\n    const jsonData = XLSX.utils.sheet_to_json(worksheet, {\r\n        header: 1,\r\n        defval: '',\r\n        blankrows: false\r\n    });\r\n\r\n    return parseStudentData(jsonData);\r\n};\r\n\r\nconst parseStudentData = (data) => {\r\n    if (data.length < 2) {\r\n        throw new Error('Excel file must contain header row and at least one student');\r\n    }\r\n\r\n    const headers = data[0].map(h =>\r\n        h?.toString().toLowerCase().trim().replace(/[^a-z0-9]/g, '') || ''\r\n    );\r\n\r\n    const columnMap = detectColumns(headers);\r\n    const students = [];\r\n\r\n    for (let i = 1; i < data.length; i++) {\r\n        const row = data[i];\r\n        if (!row || isEmptyRow(row)) continue;\r\n\r\n        const student = parseStudentRow(row, columnMap);\r\n        if (student) students.push(student);\r\n    }\r\n\r\n    return {\r\n        students,\r\n        metadata: {\r\n            totalRows: data.length - 1,\r\n            parsed: students.length,\r\n            columns: Object.keys(columnMap)\r\n        }\r\n    };\r\n};\r\n\r\nconst detectColumns = (headers) => {\r\n    const patterns = {\r\n        id: ['id', 'studentid', 'student_id', 'number', 'studentnumber'],\r\n        name: ['name', 'studentname', 'student_name', 'fullname', 'student'],\r\n        email: ['email', 'studentemail', 'student_email', 'emailaddress'],\r\n        program: ['program', 'course', 'programcode', 'coursecode'],\r\n        level: ['level', 'year', 'semester', 'term', 'grade'],\r\n        status: ['status', 'enrollment', 'active', 'enrolled'],\r\n        section: ['section', 'class', 'group']\r\n    };\r\n\r\n    const map = {};\r\n\r\n    Object.entries(patterns).forEach(([field, keywords]) => {\r\n        const index = headers.findIndex(header =>\r\n            keywords.some(keyword => header.includes(keyword))\r\n        );\r\n        if (index !== -1) map[field] = index;\r\n    });\r\n\r\n    return map;\r\n};\r\n\r\nconst parseStudentRow = (row, columnMap) => {\r\n    const getId = () => row[columnMap.id]?.toString().trim();\r\n    const getName = () => row[columnMap.name]?.toString().trim();\r\n\r\n    const id = getId();\r\n    const name = getName();\r\n\r\n    if (!id || !name) return null;\r\n\r\n    return {\r\n        id,\r\n        name,\r\n        email: row[columnMap.email]?.toString().trim() || '',\r\n        program: row[columnMap.program]?.toString().trim() || '',\r\n        level: row[columnMap.level]?.toString().trim() || '',\r\n        status: row[columnMap.status]?.toString().trim() || 'Enrolled',\r\n        section: row[columnMap.section]?.toString().trim() || '',\r\n        metadata: {\r\n            importedAt: new Date().toISOString(),\r\n            sourceRow: row\r\n        }\r\n    };\r\n};\r\n\r\nconst isEmptyRow = (row) => {\r\n    return !row || row.every(cell => !cell || cell.toString().trim() === '');\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}