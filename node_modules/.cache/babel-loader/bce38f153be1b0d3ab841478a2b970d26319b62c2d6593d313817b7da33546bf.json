{"ast":null,"code":"// Enhanced excelParser.js - Fixed version with proper table detection\nimport * as XLSX from 'xlsx';\n\n/**\r\n * Parse Excel file and extract student data with enhanced table detection\r\n * @param {File} file - Excel file to parse\r\n * @returns {Promise<Object>} - Parsed data with students array and metadata\r\n */\nexport const parseExcelFile = async file => {\n  try {\n    console.log('üîç Starting Excel file parsing:', file.name);\n    const arrayBuffer = await file.arrayBuffer();\n    const workbook = XLSX.read(arrayBuffer, {\n      type: 'array'\n    });\n    const firstSheetName = workbook.SheetNames[0];\n    const worksheet = workbook.Sheets[firstSheetName];\n    console.log('üìä Workbook sheets:', workbook.SheetNames);\n\n    // Convert to array of arrays for easier processing\n    const rawData = XLSX.utils.sheet_to_json(worksheet, {\n      header: 1,\n      defval: '',\n      blankrows: false\n    });\n    console.log(`üìã Total rows in Excel: ${rawData.length}`);\n    console.log('üîç First 15 rows for debugging:', rawData.slice(0, 15));\n\n    // Enhanced table detection\n    const tableInfo = findStudentDataTable(rawData);\n    if (!tableInfo.found) {\n      throw new Error('Could not locate student data table in Excel file');\n    }\n    console.log(`‚úÖ Student data table found:`, tableInfo);\n\n    // Extract headers and data\n    const headers = rawData[tableInfo.headerRow];\n    const dataRows = rawData.slice(tableInfo.dataStartRow, tableInfo.dataEndRow + 1);\n    console.log('üìë Detected headers:', headers);\n    console.log(`üìä Data rows to process: ${dataRows.length}`);\n\n    // Parse student data with enhanced mapping\n    const students = parseStudentData(headers, dataRows);\n    console.log(`üéì Successfully parsed ${students.length} students`);\n\n    // Extract additional course metadata from the Excel file\n    const courseMetadata = extractCourseMetadata(rawData, students);\n    return {\n      students,\n      totalRows: rawData.length,\n      dataRows: dataRows.length,\n      headers,\n      tableInfo,\n      courseMetadata,\n      rawData: rawData.slice(0, 10),\n      // Include first 10 rows for debugging\n      success: true,\n      message: `Successfully parsed ${students.length} students from ${dataRows.length} data rows`\n    };\n  } catch (error) {\n    console.error('‚ùå Excel parsing error:', error);\n    return {\n      students: [],\n      success: false,\n      error: error.message,\n      suggestions: ['Ensure the Excel file contains a student data table', 'Check that student IDs are in 6-digit format (e.g., 400001)', 'Verify column headers include ID, Name, Email, etc.', 'Make sure the file is not corrupted or password protected']\n    };\n  }\n};\n\n/**\r\n * Enhanced function to find the actual student data table within the Excel file\r\n * @param {Array} rawData - Raw Excel data as array of arrays\r\n * @returns {Object} - Table location information\r\n */\nconst findStudentDataTable = rawData => {\n  console.log('üîç Searching for student data table...');\n\n  // Simplified: find the header row by scoring \"ID, Name, Email, ...\" patterns\n  for (let i = 0; i < Math.min(rawData.length, 30); i++) {\n    const row = rawData[i] || [];\n    const score = calculateHeaderScore(row);\n    if (score >= 3) {\n      console.log(`üìã Found header row ${i} with score ${score}:`, row);\n      const headerRow = i;\n      const dataStart = i + 1;\n      const dataEnd = findDataEndRow(rawData, dataStart);\n\n      // Verify we have actual data rows after the header\n      if (dataEnd > dataStart) {\n        return {\n          found: true,\n          headerRow,\n          dataStartRow: dataStart,\n          dataEndRow: dataEnd,\n          firstStudentRow: dataStart,\n          studentsFound: dataEnd - dataStart + 1\n        };\n      }\n    }\n  }\n\n  // Secondary approach: Look for student ID patterns if header scoring fails\n  for (let rowIndex = 0; rowIndex < Math.min(rawData.length, 30); rowIndex++) {\n    const row = rawData[rowIndex];\n    if (!row || row.length === 0) continue;\n\n    // Broaden to any 5+ digit ID (not just 6-digit starting with 4)\n    const hasStudentIDs = row.some(cell => {\n      const cellStr = String(cell).trim();\n      return /^\\d{5,}$/.test(cellStr); // Matches any 5+ digit number\n    });\n    if (hasStudentIDs) {\n      console.log(`üéØ Found student IDs in row ${rowIndex}:`, row);\n\n      // Look backwards for the header row\n      const headerRow = findHeaderRow(rawData, rowIndex);\n      if (headerRow !== -1) {\n        // Find the end of data table\n        const dataEndRow = findDataEndRow(rawData, rowIndex);\n        return {\n          found: true,\n          headerRow,\n          dataStartRow: rowIndex,\n          dataEndRow,\n          firstStudentRow: rowIndex,\n          studentsFound: dataEndRow - rowIndex + 1\n        };\n      }\n    }\n  }\n  return {\n    found: false\n  };\n};\n\n/**\r\n * Find the header row by looking backwards from a student data row\r\n * @param {Array} rawData - Raw Excel data\r\n * @param {number} studentRowIndex - Index of row containing student data\r\n * @returns {number} - Header row index or -1 if not found\r\n */\nconst findHeaderRow = (rawData, studentRowIndex) => {\n  // Look up to 5 rows back for headers\n  for (let i = Math.max(0, studentRowIndex - 5); i < studentRowIndex; i++) {\n    const row = rawData[i];\n    if (!row || row.length === 0) continue;\n    const headerScore = calculateHeaderScore(row);\n    if (headerScore >= 3) {\n      console.log(`üìã Found header row ${i} with score ${headerScore}:`, row);\n      return i;\n    }\n  }\n\n  // If no clear headers found, assume the row immediately before student data\n  return Math.max(0, studentRowIndex - 1);\n};\n\n/**\r\n * Find the end of the data table\r\n * @param {Array} rawData - Raw Excel data\r\n * @param {number} startRow - Starting row index\r\n * @returns {number} - Last row index with data\r\n */\nconst findDataEndRow = (rawData, startRow) => {\n  let lastDataRow = startRow;\n  for (let i = startRow; i < rawData.length; i++) {\n    const row = rawData[i];\n\n    // Stop if we hit an empty row or summary information\n    if (!row || row.length === 0) break;\n\n    // Stop if we hit administrative text like \"Total Students:\" or \"Signature\"\n    const rowText = row.join(' ').toLowerCase();\n    if (rowText.includes('total') || rowText.includes('signature') || rowText.includes('professor') || rowText.includes('page ')) {\n      break;\n    }\n\n    // Continue if row has substantial data (at least 3 non-empty cells)\n    const nonEmptyCells = row.filter(cell => cell !== null && cell !== undefined && String(cell).trim() !== '').length;\n    if (nonEmptyCells >= 3) {\n      lastDataRow = i;\n    } else if (i > startRow + 2) {\n      // If we've seen some data and now have sparse rows, probably end of table\n      break;\n    }\n  }\n  return lastDataRow;\n};\n\n/**\r\n * Calculate how likely a row is to contain column headers\r\n * @param {Array} row - Row data\r\n * @returns {number} - Score (0-7) indicating likelihood of being headers\r\n */\nconst calculateHeaderScore = row => {\n  let score = 0;\n  const rowStr = row.join(' ').toLowerCase();\n\n  // Institutional header patterns with flexible matching\n  const headerPatterns = {\n    id: ['component', 'id', 'student id', 'studentid', 'number'],\n    name: ['name', 'student name', 'full name', 'student'],\n    email: ['email', 'e-mail', 'student email', 'emailaddress'],\n    program: ['program', 'course', 'programcode', 'coursecode'],\n    level: ['level', 'year', 'semester', 'term', 'grade'],\n    status: ['status', 'enrollment', 'active', 'enrolled'],\n    campus: ['campus', 'location', 'site']\n  };\n\n  // Check each cell for header patterns\n  row.forEach(cell => {\n    const cellStr = String(cell).trim().toLowerCase();\n    if (cellStr.length === 0) return;\n\n    // Check against all pattern categories\n    Object.values(headerPatterns).forEach(patterns => {\n      if (patterns.some(pattern => cellStr.includes(pattern) || pattern.includes(cellStr))) {\n        score++;\n      }\n    });\n  });\n  console.log(`üìä Header score for row: ${score}`, row);\n  return score;\n};\n\n/**\r\n * Enhanced student data parsing with better column mapping\r\n * @param {Array} headers - Column headers\r\n * @param {Array} dataRows - Data rows to parse\r\n * @returns {Array} - Array of student objects\r\n */\nconst parseStudentData = (headers, dataRows) => {\n  console.log('üîÑ Parsing student data with headers:', headers);\n\n  // Enhanced column mapping\n  const columnMap = mapColumns(headers);\n  console.log('üìç Column mapping:', columnMap);\n  const students = [];\n  dataRows.forEach((row, index) => {\n    try {\n      // Skip empty rows\n      if (!row || row.length === 0) return;\n\n      // Extract student data using column mapping\n      const student = {\n        id: getColumnValue(row, columnMap.id),\n        name: getColumnValue(row, columnMap.name),\n        email: getColumnValue(row, columnMap.email),\n        program: getColumnValue(row, columnMap.program),\n        level: getColumnValue(row, columnMap.level),\n        campus: getColumnValue(row, columnMap.campus),\n        status: getColumnValue(row, columnMap.status),\n        component: getColumnValue(row, columnMap.component),\n        originalRow: index,\n        rawData: row\n      };\n\n      // Validate student data - require at least ID and name\n      if (student.id && student.name && String(student.id).trim() !== '' && String(student.name).trim() !== '') {\n        // Clean up data\n        student.id = String(student.id).trim();\n        student.name = String(student.name).trim();\n        student.email = String(student.email || '').trim();\n        student.program = String(student.program || '').trim();\n        student.level = String(student.level || '').trim();\n        student.campus = String(student.campus || '').trim();\n        student.status = String(student.status || '').trim();\n        students.push(student);\n        console.log(`‚úÖ Parsed student ${students.length}:`, student);\n      } else {\n        console.log(`‚ö†Ô∏è Skipping invalid row ${index}:`, student);\n      }\n    } catch (error) {\n      console.error(`‚ùå Error parsing row ${index}:`, error, row);\n    }\n  });\n  return students;\n};\n\n/**\r\n * Enhanced column mapping with institutional patterns\r\n * @param {Array} headers - Header row\r\n * @returns {Object} - Column index mapping\r\n */\nconst mapColumns = headers => {\n  const mapping = {};\n\n  // Enhanced patterns for institutional Excel files\n  const patterns = {\n    component: ['component', 'session', 'section', 'class'],\n    id: ['id', 'student id', 'studentid', 'number', 'student number'],\n    name: ['name', 'student name', 'full name', 'student'],\n    email: ['email', 'e-mail', 'student email', 'emailaddress'],\n    program: ['program', 'course', 'programcode', 'coursecode', 'course code'],\n    level: ['level', 'year', 'semester', 'term', 'grade'],\n    campus: ['campus', 'location', 'site'],\n    status: ['status', 'enrollment', 'active', 'enrolled', 'standing']\n  };\n\n  // Map each header to a column type\n  headers.forEach((header, index) => {\n    const headerStr = String(header).trim().toLowerCase();\n    if (headerStr.length === 0) return;\n\n    // Check against each pattern category\n    Object.entries(patterns).forEach(([key, patternList]) => {\n      if (!mapping[key]) {\n        // Only assign if not already mapped\n        const match = patternList.some(pattern => headerStr.includes(pattern) || pattern.includes(headerStr));\n        if (match) {\n          mapping[key] = index;\n          console.log(`üìç Mapped \"${header}\" (index ${index}) to ${key}`);\n        }\n      }\n    });\n  });\n  return mapping;\n};\n\n/**\r\n * Get value from row using column mapping\r\n * @param {Array} row - Data row\r\n * @param {number} columnIndex - Column index\r\n * @returns {string} - Cell value or empty string\r\n */\nconst getColumnValue = (row, columnIndex) => {\n  if (columnIndex === undefined || columnIndex === null || columnIndex < 0) {\n    return '';\n  }\n  const value = row[columnIndex];\n  return value !== null && value !== undefined ? String(value).trim() : '';\n};\n\n/**\r\n * Validate student data for completeness and accuracy\r\n * @param {Array} students - Array of student objects\r\n * @returns {Object} - Validation results with statistics and issues\r\n */\nexport const validateStudentData = students => {\n  const validation = {\n    totalStudents: students.length,\n    validStudents: 0,\n    issues: [],\n    completeness: {\n      withId: 0,\n      withName: 0,\n      withEmail: 0,\n      withProgram: 0,\n      withLevel: 0,\n      withCampus: 0,\n      withStatus: 0\n    },\n    duplicateIds: [],\n    invalidEmails: [],\n    missingRequiredFields: []\n  };\n  const seenIds = new Set();\n  students.forEach((student, index) => {\n    let isValid = true;\n\n    // Check required fields\n    if (!student.id || student.id.trim() === '') {\n      validation.issues.push(`Row ${index + 1}: Missing student ID`);\n      validation.missingRequiredFields.push({\n        row: index + 1,\n        field: 'id',\n        student: student.name || 'Unknown'\n      });\n      isValid = false;\n    } else {\n      validation.completeness.withId++;\n\n      // Check for duplicate IDs\n      if (seenIds.has(student.id)) {\n        validation.duplicateIds.push({\n          id: student.id,\n          rows: [index + 1] // Could track multiple occurrences\n        });\n        validation.issues.push(`Row ${index + 1}: Duplicate student ID ${student.id}`);\n        isValid = false;\n      } else {\n        seenIds.add(student.id);\n      }\n    }\n    if (!student.name || student.name.trim() === '') {\n      validation.issues.push(`Row ${index + 1}: Missing student name`);\n      validation.missingRequiredFields.push({\n        row: index + 1,\n        field: 'name',\n        student: student.id || 'Unknown'\n      });\n      isValid = false;\n    } else {\n      validation.completeness.withName++;\n    }\n\n    // Check optional fields for completeness tracking\n    if (student.email && student.email.trim() !== '') {\n      validation.completeness.withEmail++;\n\n      // Basic email validation\n      const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n      if (!emailRegex.test(student.email)) {\n        validation.invalidEmails.push({\n          row: index + 1,\n          email: student.email,\n          student: student.name || student.id\n        });\n        validation.issues.push(`Row ${index + 1}: Invalid email format: ${student.email}`);\n      }\n    }\n    if (student.program && student.program.trim() !== '') {\n      validation.completeness.withProgram++;\n    }\n    if (student.level && student.level.trim() !== '') {\n      validation.completeness.withLevel++;\n    }\n    if (student.campus && student.campus.trim() !== '') {\n      validation.completeness.withCampus++;\n    }\n    if (student.status && student.status.trim() !== '') {\n      validation.completeness.withStatus++;\n    }\n    if (isValid) {\n      validation.validStudents++;\n    }\n  });\n\n  // Calculate completeness percentages\n  const total = students.length;\n  validation.completenessPercentages = {\n    id: total > 0 ? (validation.completeness.withId / total * 100).toFixed(1) : 0,\n    name: total > 0 ? (validation.completeness.withName / total * 100).toFixed(1) : 0,\n    email: total > 0 ? (validation.completeness.withEmail / total * 100).toFixed(1) : 0,\n    program: total > 0 ? (validation.completeness.withProgram / total * 100).toFixed(1) : 0,\n    level: total > 0 ? (validation.completeness.withLevel / total * 100).toFixed(1) : 0,\n    campus: total > 0 ? (validation.completeness.withCampus / total * 100).toFixed(1) : 0,\n    status: total > 0 ? (validation.completeness.withStatus / total * 100).toFixed(1) : 0\n  };\n\n  // Overall validation status\n  validation.isValid = validation.validStudents === validation.totalStudents;\n  validation.validationScore = total > 0 ? (validation.validStudents / total * 100).toFixed(1) : 0;\n  return validation;\n};\n\n/**\r\n * Extract course metadata from the Excel file raw data\r\n * @param {Array} rawData - Raw Excel data as array of arrays\r\n * @param {Array} students - Parsed student data\r\n * @returns {Object} - Course metadata information\r\n */\nconst extractCourseMetadata = (rawData, students) => {\n  const metadata = {\n    courseName: '',\n    courseCode: '',\n    courseOffering: '',\n    professors: '',\n    term: '',\n    campus: '',\n    hours: '',\n    component: '',\n    section: '',\n    totalStudents: students.length,\n    gradeScale: '',\n    department: ''\n  };\n\n  // Search through the first 15 rows for institutional metadata\n  for (let i = 0; i < Math.min(rawData.length, 15); i++) {\n    const row = rawData[i];\n    if (!row || row.length === 0) continue;\n    const rowText = row.join(' ').trim();\n\n    // Look for course offering pattern: \"Offered: ANM3012 - Character Dynamics and Motion\"\n    if (rowText.includes('Offered:')) {\n      const match = rowText.match(/Offered:\\s*([A-Z0-9]+)\\s*-\\s*(.+)/);\n      if (match) {\n        metadata.courseOffering = match[1]; // ANM3012\n        metadata.courseName = match[2]; // Character Dynamics and Motion\n      }\n    }\n\n    // Look for course pattern: \"Course: ART301 - Bachelor of Animation Arts Section A - Main Campus\"\n    if (rowText.includes('Course:')) {\n      const match = rowText.match(/Course:\\s*([A-Z0-9]+)\\s*-\\s*(.+)/);\n      if (match) {\n        metadata.courseCode = match[1]; // ART301\n        const fullName = match[2]; // Bachelor of Animation Arts Section A - Main Campus\n\n        // Extract section and campus\n        if (fullName.includes('Section')) {\n          const sectionMatch = fullName.match(/Section\\s+([A-Z0-9]+)/);\n          if (sectionMatch) {\n            metadata.section = `Section ${sectionMatch[1]}`;\n          }\n        }\n        if (fullName.includes('Campus')) {\n          const campusMatch = fullName.match(/(\\w+)\\s+Campus/);\n          if (campusMatch) {\n            metadata.campus = `${campusMatch[1]} Campus`;\n          }\n        }\n\n        // Extract base course name (before Section)\n        const baseNameMatch = fullName.match(/^([^-]+?)(?:\\s+Section|$)/);\n        if (baseNameMatch && !metadata.courseName) {\n          metadata.courseName = baseNameMatch[1].trim();\n        }\n      }\n    }\n\n    // NEW: Catch the generic \"CODE ‚Äì Course Name\" line (like \"DSGN8060 ‚Äì Animation Methodologies II\")\n    if (!metadata.courseCode) {\n      const hyphenMatch = rowText.match(/^([A-Z0-9]+)\\s*[‚Äì-]\\s*([^(‚Äì-]+)/);\n      if (hyphenMatch) {\n        metadata.courseCode = hyphenMatch[1].trim(); // DSGN8060\n        metadata.courseName = hyphenMatch[2].trim(); // Animation Methodologies II\n\n        // Extract additional info from the same line\n        // Look for section pattern in the same line\n        if (rowText.includes('Section')) {\n          const sectionMatch = rowText.match(/Section\\s+(\\w+)/);\n          if (sectionMatch) {\n            metadata.section = `Section ${sectionMatch[1]}`;\n          }\n        }\n\n        // Look for campus in the same line  \n        if (rowText.includes('Campus') || rowText.includes('Doon') || rowText.includes('Main')) {\n          const campusMatch = rowText.match(/(?:Section\\s+\\w+\\s*[‚Äì-]\\s*)?(\\w+)(?:\\s+Campus)?$/);\n          if (campusMatch) {\n            metadata.campus = campusMatch[1] === 'Doon' ? 'Doon Campus' : `${campusMatch[1]} Campus`;\n          }\n        }\n      }\n    }\n\n    // Look for hours: \"Hours: 2025-07-01 to 2025-10-15 (80)\"\n    if (rowText.includes('Hours:')) {\n      const match = rowText.match(/Hours:\\s*(.+)/);\n      if (match) {\n        metadata.hours = match[1].trim();\n      }\n    }\n\n    // Look for professors: \"Professors: Jordan Parker, Taylor Nguyen\"\n    if (rowText.includes('Professors:') || rowText.includes('Professor:')) {\n      const match = rowText.match(/Professors?:\\s*(.+)/);\n      if (match) {\n        metadata.professors = match[1].trim();\n      }\n    }\n\n    // Look for grade scale: \"Grade Scale: Pass 60 (C)\"\n    if (rowText.includes('Grade Scale:')) {\n      const match = rowText.match(/Grade Scale:\\s*(.+)/);\n      if (match) {\n        metadata.gradeScale = match[1].trim();\n      }\n    }\n\n    // Look for department: \"Delivery Dept: B439 - Creative Industries (DR)\"\n    if (rowText.includes('Delivery Dept:') || rowText.includes('Dept:')) {\n      const match = rowText.match(/(?:Delivery\\s+)?Dept:\\s*(.+)/);\n      if (match) {\n        metadata.department = match[1].trim();\n      }\n    }\n\n    // Look for term information\n    if (rowText.includes('Fall') || rowText.includes('Winter') || rowText.includes('Spring') || rowText.includes('Summer')) {\n      const termMatch = rowText.match(/(Fall|Winter|Spring|Summer)\\s+(\\d{4})/);\n      if (termMatch) {\n        metadata.term = `${termMatch[1]} ${termMatch[2]}`;\n      }\n    }\n  }\n\n  // Fallback to student data if metadata not found in headers\n  if (students.length > 0) {\n    const firstStudent = students[0];\n    if (!metadata.courseCode && firstStudent.program) {\n      metadata.courseCode = firstStudent.program;\n    }\n    if (!metadata.campus && firstStudent.campus) {\n      metadata.campus = firstStudent.campus;\n    }\n    if (!metadata.component && firstStudent.component) {\n      metadata.component = firstStudent.component;\n    }\n  }\n\n  // Set default values if still empty\n  if (!metadata.term) {\n    // Try to detect term from current date or filename\n    const currentDate = new Date();\n    const currentYear = currentDate.getFullYear();\n    const currentMonth = currentDate.getMonth();\n    if (currentMonth >= 8 || currentMonth <= 0) {\n      // Sept-Jan\n      metadata.term = `Fall ${currentYear}`;\n    } else if (currentMonth >= 1 && currentMonth <= 4) {\n      // Feb-May\n      metadata.term = `Winter ${currentYear}`;\n    } else {\n      // June-Aug\n      metadata.term = `Summer ${currentYear}`;\n    }\n  }\n  if (!metadata.campus) {\n    metadata.campus = 'Main Campus';\n  }\n  console.log('üìã Extracted course metadata:', metadata);\n  return metadata;\n};","map":{"version":3,"names":["XLSX","parseExcelFile","file","console","log","name","arrayBuffer","workbook","read","type","firstSheetName","SheetNames","worksheet","Sheets","rawData","utils","sheet_to_json","header","defval","blankrows","length","slice","tableInfo","findStudentDataTable","found","Error","headers","headerRow","dataRows","dataStartRow","dataEndRow","students","parseStudentData","courseMetadata","extractCourseMetadata","totalRows","success","message","error","suggestions","i","Math","min","row","score","calculateHeaderScore","dataStart","dataEnd","findDataEndRow","firstStudentRow","studentsFound","rowIndex","hasStudentIDs","some","cell","cellStr","String","trim","test","findHeaderRow","studentRowIndex","max","headerScore","startRow","lastDataRow","rowText","join","toLowerCase","includes","nonEmptyCells","filter","undefined","rowStr","headerPatterns","id","email","program","level","status","campus","forEach","Object","values","patterns","pattern","columnMap","mapColumns","index","student","getColumnValue","component","originalRow","push","mapping","headerStr","entries","key","patternList","match","columnIndex","value","validateStudentData","validation","totalStudents","validStudents","issues","completeness","withId","withName","withEmail","withProgram","withLevel","withCampus","withStatus","duplicateIds","invalidEmails","missingRequiredFields","seenIds","Set","isValid","field","has","rows","add","emailRegex","total","completenessPercentages","toFixed","validationScore","metadata","courseName","courseCode","courseOffering","professors","term","hours","section","gradeScale","department","fullName","sectionMatch","campusMatch","baseNameMatch","hyphenMatch","termMatch","firstStudent","currentDate","Date","currentYear","getFullYear","currentMonth","getMonth"],"sources":["C:/local clones/rubric-creation-app/src/utils/excelParser.js"],"sourcesContent":["// Enhanced excelParser.js - Fixed version with proper table detection\r\nimport * as XLSX from 'xlsx';\r\n\r\n/**\r\n * Parse Excel file and extract student data with enhanced table detection\r\n * @param {File} file - Excel file to parse\r\n * @returns {Promise<Object>} - Parsed data with students array and metadata\r\n */\r\nexport const parseExcelFile = async (file) => {\r\n    try {\r\n        console.log('üîç Starting Excel file parsing:', file.name);\r\n\r\n        const arrayBuffer = await file.arrayBuffer();\r\n        const workbook = XLSX.read(arrayBuffer, { type: 'array' });\r\n        const firstSheetName = workbook.SheetNames[0];\r\n        const worksheet = workbook.Sheets[firstSheetName];\r\n\r\n        console.log('üìä Workbook sheets:', workbook.SheetNames);\r\n\r\n        // Convert to array of arrays for easier processing\r\n        const rawData = XLSX.utils.sheet_to_json(worksheet, {\r\n            header: 1,\r\n            defval: '',\r\n            blankrows: false\r\n        });\r\n\r\n        console.log(`üìã Total rows in Excel: ${rawData.length}`);\r\n        console.log('üîç First 15 rows for debugging:', rawData.slice(0, 15));\r\n\r\n        // Enhanced table detection\r\n        const tableInfo = findStudentDataTable(rawData);\r\n\r\n        if (!tableInfo.found) {\r\n            throw new Error('Could not locate student data table in Excel file');\r\n        }\r\n\r\n        console.log(`‚úÖ Student data table found:`, tableInfo);\r\n\r\n        // Extract headers and data\r\n        const headers = rawData[tableInfo.headerRow];\r\n        const dataRows = rawData.slice(tableInfo.dataStartRow, tableInfo.dataEndRow + 1);\r\n\r\n        console.log('üìë Detected headers:', headers);\r\n        console.log(`üìä Data rows to process: ${dataRows.length}`);\r\n\r\n        // Parse student data with enhanced mapping\r\n        const students = parseStudentData(headers, dataRows);\r\n\r\n        console.log(`üéì Successfully parsed ${students.length} students`);\r\n\r\n        // Extract additional course metadata from the Excel file\r\n        const courseMetadata = extractCourseMetadata(rawData, students);\r\n\r\n        return {\r\n            students,\r\n            totalRows: rawData.length,\r\n            dataRows: dataRows.length,\r\n            headers,\r\n            tableInfo,\r\n            courseMetadata,\r\n            rawData: rawData.slice(0, 10), // Include first 10 rows for debugging\r\n            success: true,\r\n            message: `Successfully parsed ${students.length} students from ${dataRows.length} data rows`\r\n        };\r\n\r\n    } catch (error) {\r\n        console.error('‚ùå Excel parsing error:', error);\r\n        return {\r\n            students: [],\r\n            success: false,\r\n            error: error.message,\r\n            suggestions: [\r\n                'Ensure the Excel file contains a student data table',\r\n                'Check that student IDs are in 6-digit format (e.g., 400001)',\r\n                'Verify column headers include ID, Name, Email, etc.',\r\n                'Make sure the file is not corrupted or password protected'\r\n            ]\r\n        };\r\n    }\r\n};\r\n\r\n/**\r\n * Enhanced function to find the actual student data table within the Excel file\r\n * @param {Array} rawData - Raw Excel data as array of arrays\r\n * @returns {Object} - Table location information\r\n */\r\nconst findStudentDataTable = (rawData) => {\r\n    console.log('üîç Searching for student data table...');\r\n\r\n    // Simplified: find the header row by scoring \"ID, Name, Email, ...\" patterns\r\n    for (let i = 0; i < Math.min(rawData.length, 30); i++) {\r\n        const row = rawData[i] || [];\r\n        const score = calculateHeaderScore(row);\r\n\r\n        if (score >= 3) {\r\n            console.log(`üìã Found header row ${i} with score ${score}:`, row);\r\n\r\n            const headerRow = i;\r\n            const dataStart = i + 1;\r\n            const dataEnd = findDataEndRow(rawData, dataStart);\r\n\r\n            // Verify we have actual data rows after the header\r\n            if (dataEnd > dataStart) {\r\n                return {\r\n                    found: true,\r\n                    headerRow,\r\n                    dataStartRow: dataStart,\r\n                    dataEndRow: dataEnd,\r\n                    firstStudentRow: dataStart,\r\n                    studentsFound: dataEnd - dataStart + 1\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    // Secondary approach: Look for student ID patterns if header scoring fails\r\n    for (let rowIndex = 0; rowIndex < Math.min(rawData.length, 30); rowIndex++) {\r\n        const row = rawData[rowIndex];\r\n\r\n        if (!row || row.length === 0) continue;\r\n\r\n        // Broaden to any 5+ digit ID (not just 6-digit starting with 4)\r\n        const hasStudentIDs = row.some(cell => {\r\n            const cellStr = String(cell).trim();\r\n            return /^\\d{5,}$/.test(cellStr); // Matches any 5+ digit number\r\n        });\r\n\r\n        if (hasStudentIDs) {\r\n            console.log(`üéØ Found student IDs in row ${rowIndex}:`, row);\r\n\r\n            // Look backwards for the header row\r\n            const headerRow = findHeaderRow(rawData, rowIndex);\r\n\r\n            if (headerRow !== -1) {\r\n                // Find the end of data table\r\n                const dataEndRow = findDataEndRow(rawData, rowIndex);\r\n\r\n                return {\r\n                    found: true,\r\n                    headerRow,\r\n                    dataStartRow: rowIndex,\r\n                    dataEndRow,\r\n                    firstStudentRow: rowIndex,\r\n                    studentsFound: dataEndRow - rowIndex + 1\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    return { found: false };\r\n};\r\n\r\n/**\r\n * Find the header row by looking backwards from a student data row\r\n * @param {Array} rawData - Raw Excel data\r\n * @param {number} studentRowIndex - Index of row containing student data\r\n * @returns {number} - Header row index or -1 if not found\r\n */\r\nconst findHeaderRow = (rawData, studentRowIndex) => {\r\n    // Look up to 5 rows back for headers\r\n    for (let i = Math.max(0, studentRowIndex - 5); i < studentRowIndex; i++) {\r\n        const row = rawData[i];\r\n\r\n        if (!row || row.length === 0) continue;\r\n\r\n        const headerScore = calculateHeaderScore(row);\r\n\r\n        if (headerScore >= 3) {\r\n            console.log(`üìã Found header row ${i} with score ${headerScore}:`, row);\r\n            return i;\r\n        }\r\n    }\r\n\r\n    // If no clear headers found, assume the row immediately before student data\r\n    return Math.max(0, studentRowIndex - 1);\r\n};\r\n\r\n/**\r\n * Find the end of the data table\r\n * @param {Array} rawData - Raw Excel data\r\n * @param {number} startRow - Starting row index\r\n * @returns {number} - Last row index with data\r\n */\r\nconst findDataEndRow = (rawData, startRow) => {\r\n    let lastDataRow = startRow;\r\n\r\n    for (let i = startRow; i < rawData.length; i++) {\r\n        const row = rawData[i];\r\n\r\n        // Stop if we hit an empty row or summary information\r\n        if (!row || row.length === 0) break;\r\n\r\n        // Stop if we hit administrative text like \"Total Students:\" or \"Signature\"\r\n        const rowText = row.join(' ').toLowerCase();\r\n        if (rowText.includes('total') ||\r\n            rowText.includes('signature') ||\r\n            rowText.includes('professor') ||\r\n            rowText.includes('page ')) {\r\n            break;\r\n        }\r\n\r\n        // Continue if row has substantial data (at least 3 non-empty cells)\r\n        const nonEmptyCells = row.filter(cell =>\r\n            cell !== null && cell !== undefined && String(cell).trim() !== ''\r\n        ).length;\r\n\r\n        if (nonEmptyCells >= 3) {\r\n            lastDataRow = i;\r\n        } else if (i > startRow + 2) {\r\n            // If we've seen some data and now have sparse rows, probably end of table\r\n            break;\r\n        }\r\n    }\r\n\r\n    return lastDataRow;\r\n};\r\n\r\n/**\r\n * Calculate how likely a row is to contain column headers\r\n * @param {Array} row - Row data\r\n * @returns {number} - Score (0-7) indicating likelihood of being headers\r\n */\r\nconst calculateHeaderScore = (row) => {\r\n    let score = 0;\r\n    const rowStr = row.join(' ').toLowerCase();\r\n\r\n    // Institutional header patterns with flexible matching\r\n    const headerPatterns = {\r\n        id: ['component', 'id', 'student id', 'studentid', 'number'],\r\n        name: ['name', 'student name', 'full name', 'student'],\r\n        email: ['email', 'e-mail', 'student email', 'emailaddress'],\r\n        program: ['program', 'course', 'programcode', 'coursecode'],\r\n        level: ['level', 'year', 'semester', 'term', 'grade'],\r\n        status: ['status', 'enrollment', 'active', 'enrolled'],\r\n        campus: ['campus', 'location', 'site']\r\n    };\r\n\r\n    // Check each cell for header patterns\r\n    row.forEach(cell => {\r\n        const cellStr = String(cell).trim().toLowerCase();\r\n\r\n        if (cellStr.length === 0) return;\r\n\r\n        // Check against all pattern categories\r\n        Object.values(headerPatterns).forEach(patterns => {\r\n            if (patterns.some(pattern =>\r\n                cellStr.includes(pattern) || pattern.includes(cellStr)\r\n            )) {\r\n                score++;\r\n            }\r\n        });\r\n    });\r\n\r\n    console.log(`üìä Header score for row: ${score}`, row);\r\n    return score;\r\n};\r\n\r\n/**\r\n * Enhanced student data parsing with better column mapping\r\n * @param {Array} headers - Column headers\r\n * @param {Array} dataRows - Data rows to parse\r\n * @returns {Array} - Array of student objects\r\n */\r\nconst parseStudentData = (headers, dataRows) => {\r\n    console.log('üîÑ Parsing student data with headers:', headers);\r\n\r\n    // Enhanced column mapping\r\n    const columnMap = mapColumns(headers);\r\n    console.log('üìç Column mapping:', columnMap);\r\n\r\n    const students = [];\r\n\r\n    dataRows.forEach((row, index) => {\r\n        try {\r\n            // Skip empty rows\r\n            if (!row || row.length === 0) return;\r\n\r\n            // Extract student data using column mapping\r\n            const student = {\r\n                id: getColumnValue(row, columnMap.id),\r\n                name: getColumnValue(row, columnMap.name),\r\n                email: getColumnValue(row, columnMap.email),\r\n                program: getColumnValue(row, columnMap.program),\r\n                level: getColumnValue(row, columnMap.level),\r\n                campus: getColumnValue(row, columnMap.campus),\r\n                status: getColumnValue(row, columnMap.status),\r\n                component: getColumnValue(row, columnMap.component),\r\n                originalRow: index,\r\n                rawData: row\r\n            };\r\n\r\n            // Validate student data - require at least ID and name\r\n            if (student.id && student.name &&\r\n                String(student.id).trim() !== '' &&\r\n                String(student.name).trim() !== '') {\r\n\r\n                // Clean up data\r\n                student.id = String(student.id).trim();\r\n                student.name = String(student.name).trim();\r\n                student.email = String(student.email || '').trim();\r\n                student.program = String(student.program || '').trim();\r\n                student.level = String(student.level || '').trim();\r\n                student.campus = String(student.campus || '').trim();\r\n                student.status = String(student.status || '').trim();\r\n\r\n                students.push(student);\r\n                console.log(`‚úÖ Parsed student ${students.length}:`, student);\r\n            } else {\r\n                console.log(`‚ö†Ô∏è Skipping invalid row ${index}:`, student);\r\n            }\r\n\r\n        } catch (error) {\r\n            console.error(`‚ùå Error parsing row ${index}:`, error, row);\r\n        }\r\n    });\r\n\r\n    return students;\r\n};\r\n\r\n/**\r\n * Enhanced column mapping with institutional patterns\r\n * @param {Array} headers - Header row\r\n * @returns {Object} - Column index mapping\r\n */\r\nconst mapColumns = (headers) => {\r\n    const mapping = {};\r\n\r\n    // Enhanced patterns for institutional Excel files\r\n    const patterns = {\r\n        component: ['component', 'session', 'section', 'class'],\r\n        id: ['id', 'student id', 'studentid', 'number', 'student number'],\r\n        name: ['name', 'student name', 'full name', 'student'],\r\n        email: ['email', 'e-mail', 'student email', 'emailaddress'],\r\n        program: ['program', 'course', 'programcode', 'coursecode', 'course code'],\r\n        level: ['level', 'year', 'semester', 'term', 'grade'],\r\n        campus: ['campus', 'location', 'site'],\r\n        status: ['status', 'enrollment', 'active', 'enrolled', 'standing']\r\n    };\r\n\r\n    // Map each header to a column type\r\n    headers.forEach((header, index) => {\r\n        const headerStr = String(header).trim().toLowerCase();\r\n\r\n        if (headerStr.length === 0) return;\r\n\r\n        // Check against each pattern category\r\n        Object.entries(patterns).forEach(([key, patternList]) => {\r\n            if (!mapping[key]) { // Only assign if not already mapped\r\n                const match = patternList.some(pattern =>\r\n                    headerStr.includes(pattern) || pattern.includes(headerStr)\r\n                );\r\n\r\n                if (match) {\r\n                    mapping[key] = index;\r\n                    console.log(`üìç Mapped \"${header}\" (index ${index}) to ${key}`);\r\n                }\r\n            }\r\n        });\r\n    });\r\n\r\n    return mapping;\r\n};\r\n\r\n/**\r\n * Get value from row using column mapping\r\n * @param {Array} row - Data row\r\n * @param {number} columnIndex - Column index\r\n * @returns {string} - Cell value or empty string\r\n */\r\nconst getColumnValue = (row, columnIndex) => {\r\n    if (columnIndex === undefined || columnIndex === null || columnIndex < 0) {\r\n        return '';\r\n    }\r\n\r\n    const value = row[columnIndex];\r\n    return value !== null && value !== undefined ? String(value).trim() : '';\r\n};\r\n\r\n/**\r\n * Validate student data for completeness and accuracy\r\n * @param {Array} students - Array of student objects\r\n * @returns {Object} - Validation results with statistics and issues\r\n */\r\nexport const validateStudentData = (students) => {\r\n    const validation = {\r\n        totalStudents: students.length,\r\n        validStudents: 0,\r\n        issues: [],\r\n        completeness: {\r\n            withId: 0,\r\n            withName: 0,\r\n            withEmail: 0,\r\n            withProgram: 0,\r\n            withLevel: 0,\r\n            withCampus: 0,\r\n            withStatus: 0\r\n        },\r\n        duplicateIds: [],\r\n        invalidEmails: [],\r\n        missingRequiredFields: []\r\n    };\r\n\r\n    const seenIds = new Set();\r\n\r\n    students.forEach((student, index) => {\r\n        let isValid = true;\r\n\r\n        // Check required fields\r\n        if (!student.id || student.id.trim() === '') {\r\n            validation.issues.push(`Row ${index + 1}: Missing student ID`);\r\n            validation.missingRequiredFields.push({\r\n                row: index + 1,\r\n                field: 'id',\r\n                student: student.name || 'Unknown'\r\n            });\r\n            isValid = false;\r\n        } else {\r\n            validation.completeness.withId++;\r\n\r\n            // Check for duplicate IDs\r\n            if (seenIds.has(student.id)) {\r\n                validation.duplicateIds.push({\r\n                    id: student.id,\r\n                    rows: [index + 1] // Could track multiple occurrences\r\n                });\r\n                validation.issues.push(`Row ${index + 1}: Duplicate student ID ${student.id}`);\r\n                isValid = false;\r\n            } else {\r\n                seenIds.add(student.id);\r\n            }\r\n        }\r\n\r\n        if (!student.name || student.name.trim() === '') {\r\n            validation.issues.push(`Row ${index + 1}: Missing student name`);\r\n            validation.missingRequiredFields.push({\r\n                row: index + 1,\r\n                field: 'name',\r\n                student: student.id || 'Unknown'\r\n            });\r\n            isValid = false;\r\n        } else {\r\n            validation.completeness.withName++;\r\n        }\r\n\r\n        // Check optional fields for completeness tracking\r\n        if (student.email && student.email.trim() !== '') {\r\n            validation.completeness.withEmail++;\r\n\r\n            // Basic email validation\r\n            const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n            if (!emailRegex.test(student.email)) {\r\n                validation.invalidEmails.push({\r\n                    row: index + 1,\r\n                    email: student.email,\r\n                    student: student.name || student.id\r\n                });\r\n                validation.issues.push(`Row ${index + 1}: Invalid email format: ${student.email}`);\r\n            }\r\n        }\r\n\r\n        if (student.program && student.program.trim() !== '') {\r\n            validation.completeness.withProgram++;\r\n        }\r\n\r\n        if (student.level && student.level.trim() !== '') {\r\n            validation.completeness.withLevel++;\r\n        }\r\n\r\n        if (student.campus && student.campus.trim() !== '') {\r\n            validation.completeness.withCampus++;\r\n        }\r\n\r\n        if (student.status && student.status.trim() !== '') {\r\n            validation.completeness.withStatus++;\r\n        }\r\n\r\n        if (isValid) {\r\n            validation.validStudents++;\r\n        }\r\n    });\r\n\r\n    // Calculate completeness percentages\r\n    const total = students.length;\r\n    validation.completenessPercentages = {\r\n        id: total > 0 ? (validation.completeness.withId / total * 100).toFixed(1) : 0,\r\n        name: total > 0 ? (validation.completeness.withName / total * 100).toFixed(1) : 0,\r\n        email: total > 0 ? (validation.completeness.withEmail / total * 100).toFixed(1) : 0,\r\n        program: total > 0 ? (validation.completeness.withProgram / total * 100).toFixed(1) : 0,\r\n        level: total > 0 ? (validation.completeness.withLevel / total * 100).toFixed(1) : 0,\r\n        campus: total > 0 ? (validation.completeness.withCampus / total * 100).toFixed(1) : 0,\r\n        status: total > 0 ? (validation.completeness.withStatus / total * 100).toFixed(1) : 0\r\n    };\r\n\r\n    // Overall validation status\r\n    validation.isValid = validation.validStudents === validation.totalStudents;\r\n    validation.validationScore = total > 0 ? (validation.validStudents / total * 100).toFixed(1) : 0;\r\n\r\n    return validation;\r\n};\r\n\r\n/**\r\n * Extract course metadata from the Excel file raw data\r\n * @param {Array} rawData - Raw Excel data as array of arrays\r\n * @param {Array} students - Parsed student data\r\n * @returns {Object} - Course metadata information\r\n */\r\nconst extractCourseMetadata = (rawData, students) => {\r\n    const metadata = {\r\n        courseName: '',\r\n        courseCode: '',\r\n        courseOffering: '',\r\n        professors: '',\r\n        term: '',\r\n        campus: '',\r\n        hours: '',\r\n        component: '',\r\n        section: '',\r\n        totalStudents: students.length,\r\n        gradeScale: '',\r\n        department: ''\r\n    };\r\n\r\n    // Search through the first 15 rows for institutional metadata\r\n    for (let i = 0; i < Math.min(rawData.length, 15); i++) {\r\n        const row = rawData[i];\r\n        if (!row || row.length === 0) continue;\r\n\r\n        const rowText = row.join(' ').trim();\r\n\r\n        // Look for course offering pattern: \"Offered: ANM3012 - Character Dynamics and Motion\"\r\n        if (rowText.includes('Offered:')) {\r\n            const match = rowText.match(/Offered:\\s*([A-Z0-9]+)\\s*-\\s*(.+)/);\r\n            if (match) {\r\n                metadata.courseOffering = match[1]; // ANM3012\r\n                metadata.courseName = match[2]; // Character Dynamics and Motion\r\n            }\r\n        }\r\n\r\n        // Look for course pattern: \"Course: ART301 - Bachelor of Animation Arts Section A - Main Campus\"\r\n        if (rowText.includes('Course:')) {\r\n            const match = rowText.match(/Course:\\s*([A-Z0-9]+)\\s*-\\s*(.+)/);\r\n            if (match) {\r\n                metadata.courseCode = match[1]; // ART301\r\n                const fullName = match[2]; // Bachelor of Animation Arts Section A - Main Campus\r\n\r\n                // Extract section and campus\r\n                if (fullName.includes('Section')) {\r\n                    const sectionMatch = fullName.match(/Section\\s+([A-Z0-9]+)/);\r\n                    if (sectionMatch) {\r\n                        metadata.section = `Section ${sectionMatch[1]}`;\r\n                    }\r\n                }\r\n\r\n                if (fullName.includes('Campus')) {\r\n                    const campusMatch = fullName.match(/(\\w+)\\s+Campus/);\r\n                    if (campusMatch) {\r\n                        metadata.campus = `${campusMatch[1]} Campus`;\r\n                    }\r\n                }\r\n\r\n                // Extract base course name (before Section)\r\n                const baseNameMatch = fullName.match(/^([^-]+?)(?:\\s+Section|$)/);\r\n                if (baseNameMatch && !metadata.courseName) {\r\n                    metadata.courseName = baseNameMatch[1].trim();\r\n                }\r\n            }\r\n        }\r\n\r\n        // NEW: Catch the generic \"CODE ‚Äì Course Name\" line (like \"DSGN8060 ‚Äì Animation Methodologies II\")\r\n        if (!metadata.courseCode) {\r\n            const hyphenMatch = rowText.match(/^([A-Z0-9]+)\\s*[‚Äì-]\\s*([^(‚Äì-]+)/);\r\n            if (hyphenMatch) {\r\n                metadata.courseCode = hyphenMatch[1].trim();    // DSGN8060\r\n                metadata.courseName = hyphenMatch[2].trim();   // Animation Methodologies II\r\n\r\n                // Extract additional info from the same line\r\n                // Look for section pattern in the same line\r\n                if (rowText.includes('Section')) {\r\n                    const sectionMatch = rowText.match(/Section\\s+(\\w+)/);\r\n                    if (sectionMatch) {\r\n                        metadata.section = `Section ${sectionMatch[1]}`;\r\n                    }\r\n                }\r\n\r\n                // Look for campus in the same line  \r\n                if (rowText.includes('Campus') || rowText.includes('Doon') || rowText.includes('Main')) {\r\n                    const campusMatch = rowText.match(/(?:Section\\s+\\w+\\s*[‚Äì-]\\s*)?(\\w+)(?:\\s+Campus)?$/);\r\n                    if (campusMatch) {\r\n                        metadata.campus = campusMatch[1] === 'Doon' ? 'Doon Campus' : `${campusMatch[1]} Campus`;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Look for hours: \"Hours: 2025-07-01 to 2025-10-15 (80)\"\r\n        if (rowText.includes('Hours:')) {\r\n            const match = rowText.match(/Hours:\\s*(.+)/);\r\n            if (match) {\r\n                metadata.hours = match[1].trim();\r\n            }\r\n        }\r\n\r\n        // Look for professors: \"Professors: Jordan Parker, Taylor Nguyen\"\r\n        if (rowText.includes('Professors:') || rowText.includes('Professor:')) {\r\n            const match = rowText.match(/Professors?:\\s*(.+)/);\r\n            if (match) {\r\n                metadata.professors = match[1].trim();\r\n            }\r\n        }\r\n\r\n        // Look for grade scale: \"Grade Scale: Pass 60 (C)\"\r\n        if (rowText.includes('Grade Scale:')) {\r\n            const match = rowText.match(/Grade Scale:\\s*(.+)/);\r\n            if (match) {\r\n                metadata.gradeScale = match[1].trim();\r\n            }\r\n        }\r\n\r\n        // Look for department: \"Delivery Dept: B439 - Creative Industries (DR)\"\r\n        if (rowText.includes('Delivery Dept:') || rowText.includes('Dept:')) {\r\n            const match = rowText.match(/(?:Delivery\\s+)?Dept:\\s*(.+)/);\r\n            if (match) {\r\n                metadata.department = match[1].trim();\r\n            }\r\n        }\r\n\r\n        // Look for term information\r\n        if (rowText.includes('Fall') || rowText.includes('Winter') || rowText.includes('Spring') || rowText.includes('Summer')) {\r\n            const termMatch = rowText.match(/(Fall|Winter|Spring|Summer)\\s+(\\d{4})/);\r\n            if (termMatch) {\r\n                metadata.term = `${termMatch[1]} ${termMatch[2]}`;\r\n            }\r\n        }\r\n    }\r\n\r\n    // Fallback to student data if metadata not found in headers\r\n    if (students.length > 0) {\r\n        const firstStudent = students[0];\r\n\r\n        if (!metadata.courseCode && firstStudent.program) {\r\n            metadata.courseCode = firstStudent.program;\r\n        }\r\n\r\n        if (!metadata.campus && firstStudent.campus) {\r\n            metadata.campus = firstStudent.campus;\r\n        }\r\n\r\n        if (!metadata.component && firstStudent.component) {\r\n            metadata.component = firstStudent.component;\r\n        }\r\n    }\r\n\r\n    // Set default values if still empty\r\n    if (!metadata.term) {\r\n        // Try to detect term from current date or filename\r\n        const currentDate = new Date();\r\n        const currentYear = currentDate.getFullYear();\r\n        const currentMonth = currentDate.getMonth();\r\n\r\n        if (currentMonth >= 8 || currentMonth <= 0) { // Sept-Jan\r\n            metadata.term = `Fall ${currentYear}`;\r\n        } else if (currentMonth >= 1 && currentMonth <= 4) { // Feb-May\r\n            metadata.term = `Winter ${currentYear}`;\r\n        } else { // June-Aug\r\n            metadata.term = `Summer ${currentYear}`;\r\n        }\r\n    }\r\n\r\n    if (!metadata.campus) {\r\n        metadata.campus = 'Main Campus';\r\n    }\r\n\r\n    console.log('üìã Extracted course metadata:', metadata);\r\n    return metadata;\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}