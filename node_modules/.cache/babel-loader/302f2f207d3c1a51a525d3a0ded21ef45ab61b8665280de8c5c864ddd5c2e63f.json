{"ast":null,"code":"// src/utils/excelParser.js - UPDATED VERSION\nimport * as XLSX from 'xlsx';\n\n/**\r\n * Enhanced Excel parser with improved institutional format support\r\n * Handles both .xls and .xlsx files with flexible column detection\r\n */\n\n/**\r\n * Parse Excel file and extract student data\r\n * @param {File} file - Excel file (.xls or .xlsx)\r\n * @returns {Promise<Object>} - Parsed data with students and metadata\r\n */\nexport const parseExcelFile = async file => {\n  try {\n    console.log('üìÅ Reading Excel file:', file.name, 'Size:', file.size, 'Type:', file.type);\n\n    // Read file as array buffer\n    const arrayBuffer = await file.arrayBuffer();\n    console.log('üì¶ Array buffer size:', arrayBuffer.byteLength);\n\n    // Enhanced parsing options for better .xls/.xlsx support\n    const workbook = XLSX.read(arrayBuffer, {\n      type: 'array',\n      cellStyles: false,\n      cellDates: true,\n      dateNF: 'YYYY-MM-DD',\n      raw: false,\n      codepage: 1252,\n      // Windows encoding for older Excel files\n      cellText: false,\n      cellFormula: false\n    });\n    console.log('üìä Workbook parsed successfully');\n    console.log('üìä Available sheets:', workbook.SheetNames);\n    console.log('üìä Workbook props:', workbook.Props);\n    if (!workbook.SheetNames || workbook.SheetNames.length === 0) {\n      throw new Error('No worksheets found in the Excel file. The file may be corrupted or empty.');\n    }\n\n    // Try each sheet until we find data\n    let worksheet = null;\n    let sheetName = null;\n    let jsonData = null;\n    for (const currentSheetName of workbook.SheetNames) {\n      console.log(`üîç Checking sheet: \"${currentSheetName}\"`);\n      const currentSheet = workbook.Sheets[currentSheetName];\n      if (!currentSheet) {\n        console.log(`‚ö†Ô∏è Sheet \"${currentSheetName}\" is empty or undefined`);\n        continue;\n      }\n\n      // Get sheet range\n      const range = XLSX.utils.decode_range(currentSheet['!ref'] || 'A1:A1');\n      console.log(`üìê Sheet \"${currentSheetName}\" range:`, currentSheet['!ref'], 'Parsed range:', range);\n\n      // Try multiple conversion methods\n      const conversionMethods = [\n      // Method 1: Standard JSON conversion\n      () => XLSX.utils.sheet_to_json(currentSheet, {\n        header: 1,\n        raw: false,\n        defval: ''\n      }),\n      // Method 2: With raw values\n      () => XLSX.utils.sheet_to_json(currentSheet, {\n        header: 1,\n        raw: true,\n        defval: ''\n      }),\n      // Method 3: With range specified\n      () => XLSX.utils.sheet_to_json(currentSheet, {\n        header: 1,\n        raw: false,\n        defval: '',\n        range: 0\n      }),\n      // Method 4: CSV-style conversion\n      () => {\n        const csv = XLSX.utils.sheet_to_csv(currentSheet);\n        return csv.split('\\n').map(row => row.split(','));\n      }];\n      for (let i = 0; i < conversionMethods.length; i++) {\n        try {\n          const testData = conversionMethods[i]();\n          console.log(`üìã Method ${i + 1} result for \"${currentSheetName}\":`, testData.length, 'rows');\n          console.log(`üìã First 3 rows:`, testData.slice(0, 3));\n          if (testData && testData.length > 0) {\n            jsonData = testData;\n            worksheet = currentSheet;\n            sheetName = currentSheetName;\n            console.log(`‚úÖ Successfully parsed \"${currentSheetName}\" with method ${i + 1}`);\n            break;\n          }\n        } catch (conversionError) {\n          console.log(`‚ùå Method ${i + 1} failed for \"${currentSheetName}\":`, conversionError.message);\n        }\n      }\n      if (jsonData && jsonData.length > 0) {\n        break; // Found data, stop checking other sheets\n      }\n    }\n    if (!jsonData || jsonData.length === 0) {\n      // Last resort: try to read cell by cell\n      const firstSheet = workbook.Sheets[workbook.SheetNames[0]];\n      const cellData = [];\n      if (firstSheet['!ref']) {\n        const range = XLSX.utils.decode_range(firstSheet['!ref']);\n        console.log('üìê Trying cell-by-cell reading, range:', range);\n        for (let row = range.s.r; row <= Math.min(range.e.r, range.s.r + 50); row++) {\n          const rowData = [];\n          for (let col = range.s.c; col <= Math.min(range.e.c, range.s.c + 20); col++) {\n            const cellAddress = XLSX.utils.encode_cell({\n              r: row,\n              c: col\n            });\n            const cell = firstSheet[cellAddress];\n            rowData.push(cell ? cell.w || cell.v || '' : '');\n          }\n          if (rowData.some(cell => cell && cell.toString().trim())) {\n            cellData.push(rowData);\n          }\n        }\n        if (cellData.length > 0) {\n          jsonData = cellData;\n          console.log('‚úÖ Cell-by-cell reading successful:', cellData.length, 'rows');\n        }\n      }\n    }\n    if (!jsonData || jsonData.length === 0) {\n      throw new Error(`Could not read any data from the Excel file \"${file.name}\". The file may be corrupted, password-protected, or in an unsupported format.`);\n    }\n    console.log('üìã Final data rows:', jsonData.length);\n    console.log('üìã First few rows:', jsonData.slice(0, 5));\n    if (jsonData.length < 1) {\n      throw new Error('File appears to be empty or has no readable data');\n    }\n\n    // Extract headers (first non-empty row)\n    let headerRow = null;\n    let dataStartIndex = 0;\n    for (let i = 0; i < Math.min(jsonData.length, 10); i++) {\n      const row = jsonData[i];\n      if (row && row.length > 0 && row.some(cell => cell && cell.toString().trim())) {\n        // Check if this looks like a header row\n        const cellsWithText = row.filter(cell => cell && cell.toString().trim()).length;\n        const hasStudentDataPattern = row.some(cell => {\n          const cellStr = cell.toString().toLowerCase();\n          return cellStr.includes('id') || cellStr.includes('name') || cellStr.includes('email') || cellStr.includes('student') || cellStr.includes('component');\n        });\n        console.log(`üîç Row ${i + 1}:`, row, `Cells with text: ${cellsWithText}, Has student pattern: ${hasStudentDataPattern}`);\n        if (cellsWithText >= 3 && (hasStudentDataPattern || i === 0)) {\n          headerRow = row;\n          dataStartIndex = i + 1;\n          console.log(`‚úÖ Selected as header row: ${i + 1}`);\n          break;\n        }\n      }\n    }\n\n    // If no clear header found, use first non-empty row\n    if (!headerRow) {\n      for (let i = 0; i < Math.min(jsonData.length, 5); i++) {\n        const row = jsonData[i];\n        if (row && row.length > 0 && row.some(cell => cell && cell.toString().trim())) {\n          headerRow = row;\n          dataStartIndex = i + 1;\n          console.log(`‚ö†Ô∏è Using first non-empty row as header: ${i + 1}`);\n          break;\n        }\n      }\n    }\n    if (!headerRow) {\n      throw new Error('Could not find any data rows in Excel file. The file may be empty or formatted incorrectly.');\n    }\n    console.log('üìù Headers found:', headerRow);\n    console.log('üìç Data starts at row:', dataStartIndex + 1);\n\n    // Detect column mapping\n    const columnMapping = detectColumns(headerRow);\n    console.log('üîç Column mapping:', columnMapping);\n\n    // Extract course information from the file\n    const courseInfo = extractCourseInfo(jsonData, headerRow);\n    console.log('üéì Course info extracted:', courseInfo);\n\n    // Parse student data\n    const dataRows = jsonData.slice(dataStartIndex);\n    console.log('üìä Data rows to process:', dataRows.length);\n    const students = parseStudentData(dataRows, columnMapping);\n    console.log('üë• Students parsed:', students.length);\n\n    // If no students found but we have column mapping, provide helpful error\n    if (students.length === 0 && Object.keys(columnMapping).length > 0) {\n      console.log('üîç Column mapping exists but no students found. Checking data rows...');\n      dataRows.slice(0, 5).forEach((row, i) => {\n        console.log(`üìä Data row ${i + 1}:`, row);\n      });\n      throw new Error(`Found column headers but no valid student data in rows ${dataStartIndex + 1}-${jsonData.length}. Please check that data rows contain student information.`);\n    }\n    if (students.length === 0) {\n      throw new Error('No valid student data found. Please ensure your Excel file contains student information with ID, Name, and Email columns.');\n    }\n    return {\n      success: true,\n      students,\n      courseInfo,\n      metadata: {\n        fileName: file.name,\n        totalRows: jsonData.length,\n        dataRows: jsonData.length - dataStartIndex,\n        studentsFound: students.length,\n        columnsDetected: Object.keys(columnMapping).length,\n        headers: headerRow,\n        columnMapping\n      }\n    };\n  } catch (error) {\n    console.error('‚ùå Excel parsing error:', error);\n    return {\n      success: false,\n      error: error.message,\n      students: [],\n      courseInfo: {},\n      metadata: {\n        fileName: file.name,\n        error: error.message\n      }\n    };\n  }\n};\n\n/**\r\n * Detect column mapping from headers with enhanced institutional support\r\n * @param {Array} headers - Header row from Excel\r\n * @returns {Object} - Mapping of column indices to data types\r\n */\nconst detectColumns = headers => {\n  const mapping = {};\n\n  // Enhanced column detection patterns for institutional formats\n  const patterns = {\n    id: ['id', 'student id', 'studentid', 'student_id', 'number', 'student number', 'studentnumber', 'student_number', 'matric', 'matriculation', 'registration', 'reg', 'user id', 'userid', 'user_id'],\n    name: ['name', 'student name', 'studentname', 'student_name', 'full name', 'fullname', 'full_name', 'first name', 'firstname', 'last name', 'lastname', 'student', 'display name', 'displayname'],\n    email: ['email', 'email address', 'emailaddress', 'email_address', 'student email', 'studentemail', 'student_email', 'contact', 'e-mail', 'mail'],\n    program: ['program', 'program code', 'programcode', 'program_code', 'course', 'course code', 'coursecode', 'course_code', 'major', 'degree', 'field', 'discipline'],\n    level: ['level', 'year', 'year level', 'yearlevel', 'year_level', 'semester', 'term', 'grade', 'class', 'standing', 'academic level', 'academiclevel'],\n    status: ['status', 'enrollment', 'enrollment status', 'enrollmentstatus', 'active', 'enrolled', 'registration status', 'reg status', 'student status', 'studentstatus'],\n    section: ['section', 'class', 'group', 'class section', 'classsection', 'component', 'session', 'lab', 'tutorial'],\n    campus: ['campus', 'location', 'site', 'campus location', 'facility', 'branch']\n  };\n  headers.forEach((header, index) => {\n    if (!header) return;\n    const normalizedHeader = header.toString().toLowerCase().trim();\n    console.log(`üîç Checking header ${index}: \"${header}\" (normalized: \"${normalizedHeader}\")`);\n\n    // Check each pattern type\n    for (const [type, patternList] of Object.entries(patterns)) {\n      for (const pattern of patternList) {\n        if (normalizedHeader === pattern || normalizedHeader.includes(pattern) || pattern.includes(normalizedHeader)) {\n          console.log(`‚úÖ Matched \"${header}\" -> ${type} (pattern: \"${pattern}\")`);\n          mapping[type] = index;\n          break;\n        }\n      }\n\n      // Break outer loop if found\n      if (mapping[type] !== undefined) break;\n    }\n  });\n  console.log('üéØ Final column mapping:', mapping);\n  return mapping;\n};\n\n/**\r\n * Extract course information from Excel data\r\n * @param {Array} data - Raw Excel data\r\n * @param {Array} headers - Header row\r\n * @returns {Object} - Course information\r\n */\nconst extractCourseInfo = (data, headers) => {\n  const courseInfo = {};\n\n  // Look for course info in early rows (before student data)\n  const searchRows = data.slice(0, Math.min(10, data.length));\n  for (const row of searchRows) {\n    if (!row || row.length === 0) continue;\n    const rowText = row.join(' ').toLowerCase();\n\n    // Extract course code (pattern: letters + numbers)\n    const courseCodeMatch = rowText.match(/([a-z]{2,4}\\d{3,4})/i);\n    if (courseCodeMatch && !courseInfo.code) {\n      courseInfo.code = courseCodeMatch[1].toUpperCase();\n    }\n\n    // Extract course name (look for \"course:\" or similar patterns)\n    const courseNameMatch = rowText.match(/course[:\\s]*([^|,\\n]+)/i);\n    if (courseNameMatch && !courseInfo.name) {\n      courseInfo.name = courseNameMatch[1].trim();\n    }\n\n    // Extract semester/term info\n    const termMatch = rowText.match(/(fall|winter|spring|summer)\\s*\\d{4}/i);\n    if (termMatch && !courseInfo.term) {\n      courseInfo.term = termMatch[0];\n    }\n\n    // Look for \"offered:\" or \"hours:\" patterns\n    const offeredMatch = rowText.match(/offered[:\\s]*([^|,\\n]+)/i);\n    if (offeredMatch && !courseInfo.offered) {\n      courseInfo.offered = offeredMatch[1].trim();\n    }\n  }\n  return courseInfo;\n};\n\n/**\r\n * Parse student data from rows using column mapping\r\n * @param {Array} rows - Data rows from Excel\r\n * @param {Object} mapping - Column mapping object\r\n * @returns {Array} - Array of student objects\r\n */\nconst parseStudentData = (rows, mapping) => {\n  const students = [];\n  console.log('üë• Processing student data rows:', rows.length);\n  console.log('üó∫Ô∏è Using column mapping:', mapping);\n  rows.forEach((row, index) => {\n    try {\n      if (!row || row.length === 0) return;\n\n      // Skip empty or header-like rows\n      const nonEmptyCells = row.filter(cell => cell && cell.toString().trim()).length;\n      if (nonEmptyCells < 2) return;\n\n      // Extract data using mapping\n      const studentData = {};\n\n      // Get required fields\n      if (mapping.id !== undefined) {\n        studentData.id = row[mapping.id] ? row[mapping.id].toString().trim() : '';\n      }\n      if (mapping.name !== undefined) {\n        studentData.name = row[mapping.name] ? row[mapping.name].toString().trim() : '';\n      }\n      if (mapping.email !== undefined) {\n        studentData.email = row[mapping.email] ? row[mapping.email].toString().trim() : '';\n      }\n\n      // Get optional fields\n      if (mapping.program !== undefined) {\n        studentData.program = row[mapping.program] ? row[mapping.program].toString().trim() : '';\n      }\n      if (mapping.level !== undefined) {\n        studentData.level = row[mapping.level] ? row[mapping.level].toString().trim() : '';\n      }\n      if (mapping.status !== undefined) {\n        studentData.status = row[mapping.status] ? row[mapping.status].toString().trim() : '';\n      }\n      if (mapping.section !== undefined) {\n        studentData.section = row[mapping.section] ? row[mapping.section].toString().trim() : '';\n      }\n      if (mapping.campus !== undefined) {\n        studentData.campus = row[mapping.campus] ? row[mapping.campus].toString().trim() : '';\n      }\n      console.log(`üë§ Row ${index + 1} data:`, studentData);\n\n      // Validate required fields\n      if (!studentData.id && !studentData.name) {\n        console.log(`‚ö†Ô∏è Skipping row ${index + 1}: Missing both ID and name`);\n        return;\n      }\n\n      // Add to students array with additional metadata\n      students.push({\n        ...studentData,\n        originalRow: index + 1,\n        rawData: row\n      });\n    } catch (error) {\n      console.error(`‚ùå Error processing row ${index + 1}:`, error, row);\n    }\n  });\n  console.log(`‚úÖ Successfully parsed ${students.length} students`);\n  return students;\n};\n\n/**\r\n * Validate parsed student data\r\n * @param {Array} students - Array of student objects\r\n * @returns {Object} - Validation results\r\n */\nexport const validateStudentData = students => {\n  const validation = {\n    valid: [],\n    invalid: [],\n    warnings: [],\n    summary: {}\n  };\n  students.forEach((student, index) => {\n    const issues = [];\n\n    // Check required fields\n    if (!student.id) issues.push('Missing student ID');\n    if (!student.name) issues.push('Missing student name');\n\n    // Check email format if provided\n    if (student.email && !isValidEmail(student.email)) {\n      issues.push('Invalid email format');\n    }\n    if (issues.length === 0) {\n      validation.valid.push(student);\n    } else {\n      validation.invalid.push({\n        ...student,\n        issues\n      });\n    }\n  });\n\n  // Generate summary\n  validation.summary = {\n    total: students.length,\n    valid: validation.valid.length,\n    invalid: validation.invalid.length,\n    completeness: validation.valid.length / students.length\n  };\n  return validation;\n};\n\n/**\r\n * Simple email validation\r\n * @param {string} email - Email to validate\r\n * @returns {boolean} - Is valid email\r\n */\nconst isValidEmail = email => {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n};\nexport default {\n  parseExcelFile,\n  validateStudentData\n};","map":{"version":3,"names":["XLSX","parseExcelFile","file","console","log","name","size","type","arrayBuffer","byteLength","workbook","read","cellStyles","cellDates","dateNF","raw","codepage","cellText","cellFormula","SheetNames","Props","length","Error","worksheet","sheetName","jsonData","currentSheetName","currentSheet","Sheets","range","utils","decode_range","conversionMethods","sheet_to_json","header","defval","csv","sheet_to_csv","split","map","row","i","testData","slice","conversionError","message","firstSheet","cellData","s","r","Math","min","e","rowData","col","c","cellAddress","encode_cell","cell","push","w","v","some","toString","trim","headerRow","dataStartIndex","cellsWithText","filter","hasStudentDataPattern","cellStr","toLowerCase","includes","columnMapping","detectColumns","courseInfo","extractCourseInfo","dataRows","students","parseStudentData","Object","keys","forEach","success","metadata","fileName","totalRows","studentsFound","columnsDetected","headers","error","mapping","patterns","id","email","program","level","status","section","campus","index","normalizedHeader","patternList","entries","pattern","undefined","data","searchRows","rowText","join","courseCodeMatch","match","code","toUpperCase","courseNameMatch","termMatch","term","offeredMatch","offered","rows","nonEmptyCells","studentData","originalRow","rawData","validateStudentData","validation","valid","invalid","warnings","summary","student","issues","isValidEmail","total","completeness","emailRegex","test"],"sources":["C:/local clones/rubric-creation-app/src/utils/excelParser.js"],"sourcesContent":["// src/utils/excelParser.js - UPDATED VERSION\r\nimport * as XLSX from 'xlsx';\r\n\r\n/**\r\n * Enhanced Excel parser with improved institutional format support\r\n * Handles both .xls and .xlsx files with flexible column detection\r\n */\r\n\r\n/**\r\n * Parse Excel file and extract student data\r\n * @param {File} file - Excel file (.xls or .xlsx)\r\n * @returns {Promise<Object>} - Parsed data with students and metadata\r\n */\r\nexport const parseExcelFile = async (file) => {\r\n    try {\r\n        console.log('üìÅ Reading Excel file:', file.name, 'Size:', file.size, 'Type:', file.type);\r\n\r\n        // Read file as array buffer\r\n        const arrayBuffer = await file.arrayBuffer();\r\n        console.log('üì¶ Array buffer size:', arrayBuffer.byteLength);\r\n\r\n        // Enhanced parsing options for better .xls/.xlsx support\r\n        const workbook = XLSX.read(arrayBuffer, {\r\n            type: 'array',\r\n            cellStyles: false,\r\n            cellDates: true,\r\n            dateNF: 'YYYY-MM-DD',\r\n            raw: false,\r\n            codepage: 1252, // Windows encoding for older Excel files\r\n            cellText: false,\r\n            cellFormula: false\r\n        });\r\n\r\n        console.log('üìä Workbook parsed successfully');\r\n        console.log('üìä Available sheets:', workbook.SheetNames);\r\n        console.log('üìä Workbook props:', workbook.Props);\r\n\r\n        if (!workbook.SheetNames || workbook.SheetNames.length === 0) {\r\n            throw new Error('No worksheets found in the Excel file. The file may be corrupted or empty.');\r\n        }\r\n\r\n        // Try each sheet until we find data\r\n        let worksheet = null;\r\n        let sheetName = null;\r\n        let jsonData = null;\r\n\r\n        for (const currentSheetName of workbook.SheetNames) {\r\n            console.log(`üîç Checking sheet: \"${currentSheetName}\"`);\r\n            const currentSheet = workbook.Sheets[currentSheetName];\r\n\r\n            if (!currentSheet) {\r\n                console.log(`‚ö†Ô∏è Sheet \"${currentSheetName}\" is empty or undefined`);\r\n                continue;\r\n            }\r\n\r\n            // Get sheet range\r\n            const range = XLSX.utils.decode_range(currentSheet['!ref'] || 'A1:A1');\r\n            console.log(`üìê Sheet \"${currentSheetName}\" range:`, currentSheet['!ref'], 'Parsed range:', range);\r\n\r\n            // Try multiple conversion methods\r\n            const conversionMethods = [\r\n                // Method 1: Standard JSON conversion\r\n                () => XLSX.utils.sheet_to_json(currentSheet, {\r\n                    header: 1,\r\n                    raw: false,\r\n                    defval: ''\r\n                }),\r\n                // Method 2: With raw values\r\n                () => XLSX.utils.sheet_to_json(currentSheet, {\r\n                    header: 1,\r\n                    raw: true,\r\n                    defval: ''\r\n                }),\r\n                // Method 3: With range specified\r\n                () => XLSX.utils.sheet_to_json(currentSheet, {\r\n                    header: 1,\r\n                    raw: false,\r\n                    defval: '',\r\n                    range: 0\r\n                }),\r\n                // Method 4: CSV-style conversion\r\n                () => {\r\n                    const csv = XLSX.utils.sheet_to_csv(currentSheet);\r\n                    return csv.split('\\n').map(row => row.split(','));\r\n                }\r\n            ];\r\n\r\n            for (let i = 0; i < conversionMethods.length; i++) {\r\n                try {\r\n                    const testData = conversionMethods[i]();\r\n                    console.log(`üìã Method ${i + 1} result for \"${currentSheetName}\":`, testData.length, 'rows');\r\n                    console.log(`üìã First 3 rows:`, testData.slice(0, 3));\r\n\r\n                    if (testData && testData.length > 0) {\r\n                        jsonData = testData;\r\n                        worksheet = currentSheet;\r\n                        sheetName = currentSheetName;\r\n                        console.log(`‚úÖ Successfully parsed \"${currentSheetName}\" with method ${i + 1}`);\r\n                        break;\r\n                    }\r\n                } catch (conversionError) {\r\n                    console.log(`‚ùå Method ${i + 1} failed for \"${currentSheetName}\":`, conversionError.message);\r\n                }\r\n            }\r\n\r\n            if (jsonData && jsonData.length > 0) {\r\n                break; // Found data, stop checking other sheets\r\n            }\r\n        }\r\n\r\n        if (!jsonData || jsonData.length === 0) {\r\n            // Last resort: try to read cell by cell\r\n            const firstSheet = workbook.Sheets[workbook.SheetNames[0]];\r\n            const cellData = [];\r\n\r\n            if (firstSheet['!ref']) {\r\n                const range = XLSX.utils.decode_range(firstSheet['!ref']);\r\n                console.log('üìê Trying cell-by-cell reading, range:', range);\r\n\r\n                for (let row = range.s.r; row <= Math.min(range.e.r, range.s.r + 50); row++) {\r\n                    const rowData = [];\r\n                    for (let col = range.s.c; col <= Math.min(range.e.c, range.s.c + 20); col++) {\r\n                        const cellAddress = XLSX.utils.encode_cell({ r: row, c: col });\r\n                        const cell = firstSheet[cellAddress];\r\n                        rowData.push(cell ? (cell.w || cell.v || '') : '');\r\n                    }\r\n                    if (rowData.some(cell => cell && cell.toString().trim())) {\r\n                        cellData.push(rowData);\r\n                    }\r\n                }\r\n\r\n                if (cellData.length > 0) {\r\n                    jsonData = cellData;\r\n                    console.log('‚úÖ Cell-by-cell reading successful:', cellData.length, 'rows');\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!jsonData || jsonData.length === 0) {\r\n            throw new Error(`Could not read any data from the Excel file \"${file.name}\". The file may be corrupted, password-protected, or in an unsupported format.`);\r\n        }\r\n\r\n        console.log('üìã Final data rows:', jsonData.length);\r\n        console.log('üìã First few rows:', jsonData.slice(0, 5));\r\n\r\n        if (jsonData.length < 1) {\r\n            throw new Error('File appears to be empty or has no readable data');\r\n        }\r\n\r\n        // Extract headers (first non-empty row)\r\n        let headerRow = null;\r\n        let dataStartIndex = 0;\r\n\r\n        for (let i = 0; i < Math.min(jsonData.length, 10); i++) {\r\n            const row = jsonData[i];\r\n            if (row && row.length > 0 && row.some(cell => cell && cell.toString().trim())) {\r\n                // Check if this looks like a header row\r\n                const cellsWithText = row.filter(cell => cell && cell.toString().trim()).length;\r\n                const hasStudentDataPattern = row.some(cell => {\r\n                    const cellStr = cell.toString().toLowerCase();\r\n                    return cellStr.includes('id') || cellStr.includes('name') || cellStr.includes('email') ||\r\n                        cellStr.includes('student') || cellStr.includes('component');\r\n                });\r\n\r\n                console.log(`üîç Row ${i + 1}:`, row, `Cells with text: ${cellsWithText}, Has student pattern: ${hasStudentDataPattern}`);\r\n\r\n                if (cellsWithText >= 3 && (hasStudentDataPattern || i === 0)) {\r\n                    headerRow = row;\r\n                    dataStartIndex = i + 1;\r\n                    console.log(`‚úÖ Selected as header row: ${i + 1}`);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        // If no clear header found, use first non-empty row\r\n        if (!headerRow) {\r\n            for (let i = 0; i < Math.min(jsonData.length, 5); i++) {\r\n                const row = jsonData[i];\r\n                if (row && row.length > 0 && row.some(cell => cell && cell.toString().trim())) {\r\n                    headerRow = row;\r\n                    dataStartIndex = i + 1;\r\n                    console.log(`‚ö†Ô∏è Using first non-empty row as header: ${i + 1}`);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!headerRow) {\r\n            throw new Error('Could not find any data rows in Excel file. The file may be empty or formatted incorrectly.');\r\n        }\r\n\r\n        console.log('üìù Headers found:', headerRow);\r\n        console.log('üìç Data starts at row:', dataStartIndex + 1);\r\n\r\n        // Detect column mapping\r\n        const columnMapping = detectColumns(headerRow);\r\n        console.log('üîç Column mapping:', columnMapping);\r\n\r\n        // Extract course information from the file\r\n        const courseInfo = extractCourseInfo(jsonData, headerRow);\r\n        console.log('üéì Course info extracted:', courseInfo);\r\n\r\n        // Parse student data\r\n        const dataRows = jsonData.slice(dataStartIndex);\r\n        console.log('üìä Data rows to process:', dataRows.length);\r\n\r\n        const students = parseStudentData(dataRows, columnMapping);\r\n        console.log('üë• Students parsed:', students.length);\r\n\r\n        // If no students found but we have column mapping, provide helpful error\r\n        if (students.length === 0 && Object.keys(columnMapping).length > 0) {\r\n            console.log('üîç Column mapping exists but no students found. Checking data rows...');\r\n            dataRows.slice(0, 5).forEach((row, i) => {\r\n                console.log(`üìä Data row ${i + 1}:`, row);\r\n            });\r\n            throw new Error(`Found column headers but no valid student data in rows ${dataStartIndex + 1}-${jsonData.length}. Please check that data rows contain student information.`);\r\n        }\r\n\r\n        if (students.length === 0) {\r\n            throw new Error('No valid student data found. Please ensure your Excel file contains student information with ID, Name, and Email columns.');\r\n        }\r\n\r\n        return {\r\n            success: true,\r\n            students,\r\n            courseInfo,\r\n            metadata: {\r\n                fileName: file.name,\r\n                totalRows: jsonData.length,\r\n                dataRows: jsonData.length - dataStartIndex,\r\n                studentsFound: students.length,\r\n                columnsDetected: Object.keys(columnMapping).length,\r\n                headers: headerRow,\r\n                columnMapping\r\n            }\r\n        };\r\n\r\n    } catch (error) {\r\n        console.error('‚ùå Excel parsing error:', error);\r\n        return {\r\n            success: false,\r\n            error: error.message,\r\n            students: [],\r\n            courseInfo: {},\r\n            metadata: {\r\n                fileName: file.name,\r\n                error: error.message\r\n            }\r\n        };\r\n    }\r\n};\r\n\r\n/**\r\n * Detect column mapping from headers with enhanced institutional support\r\n * @param {Array} headers - Header row from Excel\r\n * @returns {Object} - Mapping of column indices to data types\r\n */\r\nconst detectColumns = (headers) => {\r\n    const mapping = {};\r\n\r\n    // Enhanced column detection patterns for institutional formats\r\n    const patterns = {\r\n        id: [\r\n            'id', 'student id', 'studentid', 'student_id',\r\n            'number', 'student number', 'studentnumber', 'student_number',\r\n            'matric', 'matriculation', 'registration', 'reg',\r\n            'user id', 'userid', 'user_id'\r\n        ],\r\n        name: [\r\n            'name', 'student name', 'studentname', 'student_name',\r\n            'full name', 'fullname', 'full_name',\r\n            'first name', 'firstname', 'last name', 'lastname',\r\n            'student', 'display name', 'displayname'\r\n        ],\r\n        email: [\r\n            'email', 'email address', 'emailaddress', 'email_address',\r\n            'student email', 'studentemail', 'student_email',\r\n            'contact', 'e-mail', 'mail'\r\n        ],\r\n        program: [\r\n            'program', 'program code', 'programcode', 'program_code',\r\n            'course', 'course code', 'coursecode', 'course_code',\r\n            'major', 'degree', 'field', 'discipline'\r\n        ],\r\n        level: [\r\n            'level', 'year', 'year level', 'yearlevel', 'year_level',\r\n            'semester', 'term', 'grade', 'class',\r\n            'standing', 'academic level', 'academiclevel'\r\n        ],\r\n        status: [\r\n            'status', 'enrollment', 'enrollment status', 'enrollmentstatus',\r\n            'active', 'enrolled', 'registration status', 'reg status',\r\n            'student status', 'studentstatus'\r\n        ],\r\n        section: [\r\n            'section', 'class', 'group', 'class section', 'classsection',\r\n            'component', 'session', 'lab', 'tutorial'\r\n        ],\r\n        campus: [\r\n            'campus', 'location', 'site', 'campus location',\r\n            'facility', 'branch'\r\n        ]\r\n    };\r\n\r\n    headers.forEach((header, index) => {\r\n        if (!header) return;\r\n\r\n        const normalizedHeader = header.toString().toLowerCase().trim();\r\n        console.log(`üîç Checking header ${index}: \"${header}\" (normalized: \"${normalizedHeader}\")`);\r\n\r\n        // Check each pattern type\r\n        for (const [type, patternList] of Object.entries(patterns)) {\r\n            for (const pattern of patternList) {\r\n                if (normalizedHeader === pattern ||\r\n                    normalizedHeader.includes(pattern) ||\r\n                    pattern.includes(normalizedHeader)) {\r\n\r\n                    console.log(`‚úÖ Matched \"${header}\" -> ${type} (pattern: \"${pattern}\")`);\r\n                    mapping[type] = index;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            // Break outer loop if found\r\n            if (mapping[type] !== undefined) break;\r\n        }\r\n    });\r\n\r\n    console.log('üéØ Final column mapping:', mapping);\r\n    return mapping;\r\n};\r\n\r\n/**\r\n * Extract course information from Excel data\r\n * @param {Array} data - Raw Excel data\r\n * @param {Array} headers - Header row\r\n * @returns {Object} - Course information\r\n */\r\nconst extractCourseInfo = (data, headers) => {\r\n    const courseInfo = {};\r\n\r\n    // Look for course info in early rows (before student data)\r\n    const searchRows = data.slice(0, Math.min(10, data.length));\r\n\r\n    for (const row of searchRows) {\r\n        if (!row || row.length === 0) continue;\r\n\r\n        const rowText = row.join(' ').toLowerCase();\r\n\r\n        // Extract course code (pattern: letters + numbers)\r\n        const courseCodeMatch = rowText.match(/([a-z]{2,4}\\d{3,4})/i);\r\n        if (courseCodeMatch && !courseInfo.code) {\r\n            courseInfo.code = courseCodeMatch[1].toUpperCase();\r\n        }\r\n\r\n        // Extract course name (look for \"course:\" or similar patterns)\r\n        const courseNameMatch = rowText.match(/course[:\\s]*([^|,\\n]+)/i);\r\n        if (courseNameMatch && !courseInfo.name) {\r\n            courseInfo.name = courseNameMatch[1].trim();\r\n        }\r\n\r\n        // Extract semester/term info\r\n        const termMatch = rowText.match(/(fall|winter|spring|summer)\\s*\\d{4}/i);\r\n        if (termMatch && !courseInfo.term) {\r\n            courseInfo.term = termMatch[0];\r\n        }\r\n\r\n        // Look for \"offered:\" or \"hours:\" patterns\r\n        const offeredMatch = rowText.match(/offered[:\\s]*([^|,\\n]+)/i);\r\n        if (offeredMatch && !courseInfo.offered) {\r\n            courseInfo.offered = offeredMatch[1].trim();\r\n        }\r\n    }\r\n\r\n    return courseInfo;\r\n};\r\n\r\n/**\r\n * Parse student data from rows using column mapping\r\n * @param {Array} rows - Data rows from Excel\r\n * @param {Object} mapping - Column mapping object\r\n * @returns {Array} - Array of student objects\r\n */\r\nconst parseStudentData = (rows, mapping) => {\r\n    const students = [];\r\n\r\n    console.log('üë• Processing student data rows:', rows.length);\r\n    console.log('üó∫Ô∏è Using column mapping:', mapping);\r\n\r\n    rows.forEach((row, index) => {\r\n        try {\r\n            if (!row || row.length === 0) return;\r\n\r\n            // Skip empty or header-like rows\r\n            const nonEmptyCells = row.filter(cell => cell && cell.toString().trim()).length;\r\n            if (nonEmptyCells < 2) return;\r\n\r\n            // Extract data using mapping\r\n            const studentData = {};\r\n\r\n            // Get required fields\r\n            if (mapping.id !== undefined) {\r\n                studentData.id = row[mapping.id] ? row[mapping.id].toString().trim() : '';\r\n            }\r\n\r\n            if (mapping.name !== undefined) {\r\n                studentData.name = row[mapping.name] ? row[mapping.name].toString().trim() : '';\r\n            }\r\n\r\n            if (mapping.email !== undefined) {\r\n                studentData.email = row[mapping.email] ? row[mapping.email].toString().trim() : '';\r\n            }\r\n\r\n            // Get optional fields\r\n            if (mapping.program !== undefined) {\r\n                studentData.program = row[mapping.program] ? row[mapping.program].toString().trim() : '';\r\n            }\r\n\r\n            if (mapping.level !== undefined) {\r\n                studentData.level = row[mapping.level] ? row[mapping.level].toString().trim() : '';\r\n            }\r\n\r\n            if (mapping.status !== undefined) {\r\n                studentData.status = row[mapping.status] ? row[mapping.status].toString().trim() : '';\r\n            }\r\n\r\n            if (mapping.section !== undefined) {\r\n                studentData.section = row[mapping.section] ? row[mapping.section].toString().trim() : '';\r\n            }\r\n\r\n            if (mapping.campus !== undefined) {\r\n                studentData.campus = row[mapping.campus] ? row[mapping.campus].toString().trim() : '';\r\n            }\r\n\r\n            console.log(`üë§ Row ${index + 1} data:`, studentData);\r\n\r\n            // Validate required fields\r\n            if (!studentData.id && !studentData.name) {\r\n                console.log(`‚ö†Ô∏è Skipping row ${index + 1}: Missing both ID and name`);\r\n                return;\r\n            }\r\n\r\n            // Add to students array with additional metadata\r\n            students.push({\r\n                ...studentData,\r\n                originalRow: index + 1,\r\n                rawData: row\r\n            });\r\n\r\n        } catch (error) {\r\n            console.error(`‚ùå Error processing row ${index + 1}:`, error, row);\r\n        }\r\n    });\r\n\r\n    console.log(`‚úÖ Successfully parsed ${students.length} students`);\r\n    return students;\r\n};\r\n\r\n/**\r\n * Validate parsed student data\r\n * @param {Array} students - Array of student objects\r\n * @returns {Object} - Validation results\r\n */\r\nexport const validateStudentData = (students) => {\r\n    const validation = {\r\n        valid: [],\r\n        invalid: [],\r\n        warnings: [],\r\n        summary: {}\r\n    };\r\n\r\n    students.forEach((student, index) => {\r\n        const issues = [];\r\n\r\n        // Check required fields\r\n        if (!student.id) issues.push('Missing student ID');\r\n        if (!student.name) issues.push('Missing student name');\r\n\r\n        // Check email format if provided\r\n        if (student.email && !isValidEmail(student.email)) {\r\n            issues.push('Invalid email format');\r\n        }\r\n\r\n        if (issues.length === 0) {\r\n            validation.valid.push(student);\r\n        } else {\r\n            validation.invalid.push({\r\n                ...student,\r\n                issues\r\n            });\r\n        }\r\n    });\r\n\r\n    // Generate summary\r\n    validation.summary = {\r\n        total: students.length,\r\n        valid: validation.valid.length,\r\n        invalid: validation.invalid.length,\r\n        completeness: validation.valid.length / students.length\r\n    };\r\n\r\n    return validation;\r\n};\r\n\r\n/**\r\n * Simple email validation\r\n * @param {string} email - Email to validate\r\n * @returns {boolean} - Is valid email\r\n */\r\nconst isValidEmail = (email) => {\r\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n    return emailRegex.test(email);\r\n};\r\n\r\nexport default {\r\n    parseExcelFile,\r\n    validateStudentData\r\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}