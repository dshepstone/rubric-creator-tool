// Complete SharedContext.js - Fully Merged with ALL Original Features + Late Policy Enhancement
// This version preserves EVERY function and feature from the original while adding late policy support

import React, { createContext, useContext, useState, useCallback } from 'react';

const AssessmentContext = createContext();

export const useAssessment = () => {
    const context = useContext(AssessmentContext);
    if (!context) {
        throw new Error('useAssessment must be used within AssessmentProvider');
    }
    return context;
};

export const AssessmentProvider = ({ children }) => {
    // ORIGINAL: Shared rubric state
    const [sharedRubric, setSharedRubric] = useState(null);
    const [sharedCourseDetails, setSharedCourseDetails] = useState(null);
    const [activeTab, setActiveTab] = useState('assignment-prompt-generator');

    // ORIGINAL: AI Prompt Generator state (for rubrics)
    const [aiPromptFormData, setAIPromptFormData] = useState(null);

    // ORIGINAL: Assignment Prompt Generator state
    const [assignmentPromptFormData, setAssignmentPromptFormData] = useState(null);

    // ORIGINAL: Class list and student management
    const [classList, setClassList] = useState(null);
    const [currentStudent, setCurrentStudent] = useState(null);

    // ORIGINAL: Separate storage for draft and final grades
    const [drafts, setDrafts] = useState({});
    const [finalGrades, setFinalGrades] = useState({});

    // NEW: Late Policy State Management
    const [currentLatePolicy, setCurrentLatePolicy] = useState(null);
    const [customLatePolicies, setCustomLatePolicies] = useState([]);

    // ORIGINAL: Batch grading session state
    const [gradingSession, setGradingSession] = useState({
        active: false,
        startTime: null,
        gradedStudents: [],
        totalStudents: 0,
        currentStudent: null,
        currentStudentIndex: 0
    });

    // ENHANCED: Form data states with late policy support
    const [gradingFormData, setGradingFormData] = useState({
        student: { name: '', id: '', email: '' },
        course: { code: '', name: '', instructor: '', term: '' },
        assignment: { name: '', dueDate: '', maxPoints: 100 },
        feedback: { general: '', strengths: '', improvements: '' },
        attachments: [],
        videoLinks: [],
        latePolicy: { 
            level: 'none', 
            penaltyApplied: false,
            policyId: null,
            originalScore: null,
            adjustedScore: null,
            multiplier: 1.0
        },
        rubricGrading: {},
        metadata: {
            gradedBy: '',
            gradedDate: '',
            aiAssisted: false,
            rubricIntegrated: false
        }
    });

    // ORIGINAL: Rubric form data state
    const [rubricFormData, setRubricFormData] = useState({
        assignmentInfo: {
            title: '',
            description: '',
            weight: 25,
            passingThreshold: 60,
            totalPoints: 100
        },
        rubricLevels: [
            { level: 'incomplete', name: 'Incomplete', description: 'No submission or unusable', color: '#95a5a6', multiplier: 0 },
            { level: 'unacceptable', name: 'Unacceptable', description: 'Below minimum standards', color: '#e74c3c', multiplier: 0.3 },
            { level: 'developing', name: 'Developing', description: 'Approaching standards', color: '#f39c12', multiplier: 0.55 },
            { level: 'acceptable', name: 'Acceptable (PASS)', description: 'Meets minimum standards', color: '#27ae60', multiplier: 0.7 },
            { level: 'emerging', name: 'Emerging', description: 'Above standard expectations', color: '#2980b9', multiplier: 0.82 },
            { level: 'accomplished', name: 'Accomplished', description: 'Strong professional quality', color: '#16a085', multiplier: 0.92 },
            { level: 'exceptional', name: 'Exceptional', description: 'Outstanding professional quality', color: '#8e44ad', multiplier: 1.0 }
        ],
        criteria: [
            {
                id: 'criterion-1',
                name: '',
                description: '',
                maxPoints: 20,
                weight: 20,
                levels: {},
                feedbackLibrary: {
                    strengths: [],
                    improvements: [],
                    general: []
                }
            }
        ],
        pointingSystem: 'multiplier',
        reversedOrder: false,
        expandedFeedback: {},
        modalEdit: { show: false, content: '', field: null, onSave: null }
    });

    // ORIGINAL: AI Prompt Generator functions (for rubrics)
    const initializeAIPromptFormData = useCallback(() => {
        setAIPromptFormData({
            assignmentType: '',
            programType: 'Diploma',
            programLevel: 'Level (Semester) 3',
            subjectArea: '',
            assignmentDescription: '',
            criteriaType: 'ai-suggested',
            numCriteria: '4',
            timeFrameUnit: 'weeks',
            totalPoints: '100',
            learningObjectives: '',
            additionalContext: ''
        });
    }, []);

    const updateAIPromptFormData = useCallback((field, value) => {
        setAIPromptFormData(prevData => ({
            ...prevData,
            [field]: value
        }));
    }, []);

    const clearAIPromptFormData = useCallback(() => {
        setAIPromptFormData(null);
    }, []);

    // ORIGINAL: Assignment Prompt Generator functions
    const initializeAssignmentPromptFormData = useCallback(() => {
        setAssignmentPromptFormData({
            assignmentTitle: '',
            subjectArea: '',
            programLevel: '',
            assignmentDescription: '',
            weightPercentage: '',
            clos: ['', '', ''],
            skillsAssessed: ['', '', ''],
            dueDate: '',
            deliverables: [''],
            evaluationCriteria: [''],
            additionalInfo: ''
        });
    }, []);

    const updateAssignmentPromptFormData = useCallback((field, value) => {
        setAssignmentPromptFormData(prevData => ({
            ...prevData,
            [field]: value
        }));
    }, []);

    const clearAssignmentPromptFormData = useCallback(() => {
        setAssignmentPromptFormData(null);
    }, []);

    // ORIGINAL: Form update functions
    const updateStudentInfo = useCallback((field, value) => {
        setGradingFormData(prevData => ({
            ...prevData,
            student: { ...prevData.student, [field]: value }
        }));
    }, []);

    const updateCourseInfo = useCallback((field, value) => {
        setGradingFormData(prevData => ({
            ...prevData,
            course: { ...prevData.course, [field]: value }
        }));
    }, []);

    const updateAssignmentInfo = useCallback((field, value) => {
        setGradingFormData(prevData => ({
            ...prevData,
            assignment: { ...prevData.assignment, [field]: value }
        }));
    }, []);

    const updateFeedbackInfo = useCallback((field, value) => {
        setGradingFormData(prevData => ({
            ...prevData,
            feedback: { ...prevData.feedback, [field]: value }
        }));
    }, []);

    const updateAttachments = useCallback((attachments) => {
        setGradingFormData(prevData => ({
            ...prevData,
            attachments: attachments
        }));
    }, []);

    const updateVideoLinks = useCallback((links) => {
        setGradingFormData(prevData => ({
            ...prevData,
            videoLinks: links
        }));
    }, []);

    // NEW: Enhanced Late Policy Management Functions
    const updateLatePolicyInfo = useCallback((field, value) => {
        setGradingFormData(prevData => ({
            ...prevData,
            latePolicy: { ...prevData.latePolicy, [field]: value }
        }));
    }, []);

    const applyLatePolicy = useCallback((policyId, level, originalScore) => {
        const policy = customLatePolicies.find(p => p.id === policyId) || currentLatePolicy;
        if (!policy || !policy.levels[level]) return originalScore;

        const multiplier = policy.levels[level].multiplier;
        const adjustedScore = originalScore * multiplier;

        setGradingFormData(prevData => ({
            ...prevData,
            latePolicy: {
                ...prevData.latePolicy,
                level: level,
                policyId: policyId,
                originalScore: originalScore,
                adjustedScore: adjustedScore,
                multiplier: multiplier,
                penaltyApplied: level !== 'none'
            }
        }));

        return adjustedScore;
    }, [customLatePolicies, currentLatePolicy]);

    const calculateScoreWithLatePolicy = useCallback((rawScore, latePolicyLevel = null) => {
        const level = latePolicyLevel || gradingFormData.latePolicy.level;
        const policy = currentLatePolicy;
        
        if (!policy || !policy.levels[level] || level === 'none') {
            return {
                rawScore: rawScore,
                finalScore: rawScore,
                penaltyApplied: false,
                multiplier: 1.0,
                policyDescription: 'No late penalty applied'
            };
        }

        const multiplier = policy.levels[level].multiplier;
        const finalScore = rawScore * multiplier;

        return {
            rawScore: rawScore,
            finalScore: finalScore,
            penaltyApplied: true,
            multiplier: multiplier,
            policyDescription: policy.levels[level].description,
            penaltyAmount: rawScore - finalScore
        };
    }, [currentLatePolicy, gradingFormData.latePolicy.level]);

    // NEW: Late Policy CRUD Operations
    const saveCustomLatePolicy = useCallback((policyData) => {
        const newPolicy = {
            ...policyData,
            id: `custom_${Date.now()}`,
            isCustom: true,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString()
        };

        setCustomLatePolicies(prev => [...prev, newPolicy]);
        
        // Save to localStorage
        const updatedPolicies = [...customLatePolicies, newPolicy];
        localStorage.setItem('customLatePolicies', JSON.stringify(updatedPolicies));
        
        return newPolicy;
    }, [customLatePolicies]);

    const updateCustomLatePolicy = useCallback((policyId, policyData) => {
        const updatedPolicies = customLatePolicies.map(policy => 
            policy.id === policyId 
                ? { ...policyData, id: policyId, isCustom: true, updatedAt: new Date().toISOString() }
                : policy
        );

        setCustomLatePolicies(updatedPolicies);
        localStorage.setItem('customLatePolicies', JSON.stringify(updatedPolicies));

        // Update current policy if it's the one being edited
        if (currentLatePolicy?.id === policyId) {
            setCurrentLatePolicy({ ...policyData, id: policyId, isCustom: true });
        }
    }, [customLatePolicies, currentLatePolicy]);

    const deleteCustomLatePolicy = useCallback((policyId) => {
        const updatedPolicies = customLatePolicies.filter(policy => policy.id !== policyId);
        setCustomLatePolicies(updatedPolicies);
        localStorage.setItem('customLatePolicies', JSON.stringify(updatedPolicies));

        // Reset to default if deleted policy was current
        if (currentLatePolicy?.id === policyId) {
            setCurrentLatePolicy(null);
        }
    }, [customLatePolicies, currentLatePolicy]);

    const loadLatePoliciesFromStorage = useCallback(() => {
        try {
            const savedPolicies = localStorage.getItem('customLatePolicies');
            if (savedPolicies) {
                setCustomLatePolicies(JSON.parse(savedPolicies));
            }

            const savedCurrentPolicy = localStorage.getItem('currentLatePolicy');
            if (savedCurrentPolicy) {
                setCurrentLatePolicy(JSON.parse(savedCurrentPolicy));
            }
        } catch (error) {
            console.error('Error loading late policies from storage:', error);
        }
    }, []);

    // ORIGINAL: Rubric grading and metadata functions
    const updateRubricGrading = useCallback((criterionId, data) => {
        setGradingFormData(prevData => ({
            ...prevData,
            rubricGrading: { ...prevData.rubricGrading, [criterionId]: data }
        }));
    }, []);

    const updateMetadata = useCallback((field, value) => {
        setGradingFormData(prevData => ({
            ...prevData,
            metadata: { ...prevData.metadata, [field]: value }
        }));
    }, []);

    // ORIGINAL: Clear functions
    const clearGradingFormData = useCallback(() => {
        setGradingFormData({
            student: { name: '', id: '', email: '' },
            course: { code: '', name: '', instructor: '', term: '' },
            assignment: { name: '', dueDate: '', maxPoints: 100 },
            feedback: { general: '', strengths: '', improvements: '' },
            attachments: [],
            videoLinks: [],
            latePolicy: { 
                level: 'none', 
                penaltyApplied: false,
                policyId: null,
                originalScore: null,
                adjustedScore: null,
                multiplier: 1.0
            },
            rubricGrading: {},
            metadata: {
                gradedBy: '',
                gradedDate: '',
                aiAssisted: false,
                rubricIntegrated: false
            }
        });
    }, []);

    const clearRubricFormData = useCallback(() => {
        setRubricFormData({
            assignmentInfo: {
                title: '',
                description: '',
                weight: 25,
                passingThreshold: 60,
                totalPoints: 100
            },
            rubricLevels: [
                { level: 'incomplete', name: 'Incomplete', description: 'No submission or unusable', color: '#95a5a6', multiplier: 0 },
                { level: 'unacceptable', name: 'Unacceptable', description: 'Below minimum standards', color: '#e74c3c', multiplier: 0.3 },
                { level: 'developing', name: 'Developing', description: 'Approaching standards', color: '#f39c12', multiplier: 0.55 },
                { level: 'acceptable', name: 'Acceptable (PASS)', description: 'Meets minimum standards', color: '#27ae60', multiplier: 0.7 },
                { level: 'emerging', name: 'Emerging', description: 'Above standard expectations', color: '#2980b9', multiplier: 0.82 },
                { level: 'accomplished', name: 'Accomplished', description: 'Strong professional quality', color: '#16a085', multiplier: 0.92 },
                { level: 'exceptional', name: 'Exceptional', description: 'Outstanding professional quality', color: '#8e44ad', multiplier: 1.0 }
            ],
            criteria: [
                {
                    id: 'criterion-1',
                    name: '',
                    description: '',
                    maxPoints: 20,
                    weight: 20,
                    levels: {},
                    feedbackLibrary: {
                        strengths: [],
                        improvements: [],
                        general: []
                    }
                }
            ],
            pointingSystem: 'multiplier',
            reversedOrder: false,
            expandedFeedback: {},
            modalEdit: { show: false, content: '', field: null, onSave: null }
        });
    }, []);

    // ENHANCED: Draft and Final Grade Management with Late Policy Support
    const saveDraft = useCallback((studentId, gradeData) => {
        const draftData = {
            ...gradeData,
            latePolicy: gradingFormData.latePolicy,
            savedAt: new Date().toISOString(),
            type: 'draft'
        };

        setDrafts(prev => ({
            ...prev,
            [studentId]: draftData
        }));

        // Save to localStorage
        const allDrafts = { ...drafts, [studentId]: draftData };
        localStorage.setItem('gradingDrafts', JSON.stringify(allDrafts));

        return draftData;
    }, [gradingFormData.latePolicy, drafts]);

    const loadDraft = useCallback((studentId) => {
        const draft = drafts[studentId];
        if (draft) {
            setGradingFormData(prev => ({
                ...prev,
                ...draft,
                latePolicy: draft.latePolicy || prev.latePolicy
            }));
        }
        return draft;
    }, [drafts]);

    const saveFinalGrade = useCallback((studentId, gradeData) => {
        const finalData = {
            ...gradeData,
            latePolicy: gradingFormData.latePolicy,
            finalizedAt: new Date().toISOString(),
            type: 'final'
        };

        setFinalGrades(prev => ({
            ...prev,
            [studentId]: finalData
        }));

        // Remove from drafts
        setDrafts(prev => {
            const newDrafts = { ...prev };
            delete newDrafts[studentId];
            return newDrafts;
        });

        // Save to localStorage
        const allFinalGrades = { ...finalGrades, [studentId]: finalData };
        localStorage.setItem('finalGrades', JSON.stringify(allFinalGrades));
        
        const remainingDrafts = { ...drafts };
        delete remainingDrafts[studentId];
        localStorage.setItem('gradingDrafts', JSON.stringify(remainingDrafts));

        return finalData;
    }, [gradingFormData.latePolicy, finalGrades, drafts]);

    const loadFinalGrade = useCallback((studentId) => {
        return finalGrades[studentId] || null;
    }, [finalGrades]);

    const hasDraft = useCallback((studentId) => {
        return drafts[studentId] || null;
    }, [drafts]);

    const getGradeStatus = useCallback((studentId) => {
        if (finalGrades[studentId]) return 'final';
        if (drafts[studentId]) return 'draft';
        return 'not_started';
    }, [finalGrades, drafts]);

    const finalizeGrade = useCallback((studentId) => {
        const draft = drafts[studentId];
        if (draft) {
            return saveFinalGrade(studentId, draft);
        }
        return null;
    }, [drafts, saveFinalGrade]);

    const unlockGrade = useCallback((studentId) => {
        const finalGrade = finalGrades[studentId];
        if (finalGrade) {
            // Convert final grade back to draft
            setDrafts(prev => ({
                ...prev,
                [studentId]: {
                    ...finalGrade,
                    type: 'draft',
                    unlockedAt: new Date().toISOString()
                }
            }));

            // Remove from final grades
            setFinalGrades(prev => {
                const newFinalGrades = { ...prev };
                delete newFinalGrades[studentId];
                return newFinalGrades;
            });

            // Update localStorage
            const allDrafts = { ...drafts, [studentId]: { ...finalGrade, type: 'draft' } };
            localStorage.setItem('gradingDrafts', JSON.stringify(allDrafts));
            
            const remainingFinalGrades = { ...finalGrades };
            delete remainingFinalGrades[studentId];
            localStorage.setItem('finalGrades', JSON.stringify(remainingFinalGrades));

            return true;
        }
        return false;
    }, [finalGrades, drafts]);

    // ORIGINAL: Navigation helpers for grading sessions
    const nextStudentInSession = useCallback((saveType = 'draft') => {
        if (!gradingSession?.active || !classList) return false;

        const currentIndex = gradingSession.currentStudentIndex;
        const students = classList.students;

        if (currentIndex < students.length - 1) {
            const nextIndex = currentIndex + 1;
            const nextStudent = students[nextIndex];

            setGradingSession(prev => ({
                ...prev,
                currentStudentIndex: nextIndex,
                currentStudent: nextStudent,
                gradedStudents: [...prev.gradedStudents, currentStudent.id]
            }));

            setCurrentStudent(nextStudent);
            return true;
        }

        setGradingSession(prev => ({
            ...prev,
            active: false,
            gradedStudents: [...prev.gradedStudents, currentStudent.id]
        }));
        return false;
    }, [gradingSession, classList, currentStudent]);

    const previousStudentInSession = useCallback(() => {
        if (!gradingSession?.active || !classList) return false;

        const currentIndex = gradingSession.currentStudentIndex;
        if (currentIndex > 0) {
            const prevIndex = currentIndex - 1;
            const prevStudent = classList.students[prevIndex];

            setGradingSession(prev => ({
                ...prev,
                currentStudentIndex: prevIndex,
                currentStudent: prevStudent
            }));

            setCurrentStudent(prevStudent);
            return true;
        }
        return false;
    }, [gradingSession, classList]);

    // ORIGINAL: Enhanced initializeGradingSession function
    const initializeGradingSession = useCallback((classListData) => {
        if (!classListData || !classListData.students?.length) {
            console.warn('⚠️ Cannot initialize grading session: No students found');
            return false;
        }

        const { students, courseMetadata } = classListData;
        const firstStudent = students[0];

        setGradingSession({
            active: true,
            startTime: new Date().toISOString(),
            gradedStudents: [],
            totalStudents: students.length,
            currentStudent: firstStudent,
            currentStudentIndex: 0
        });

        setCurrentStudent(firstStudent);

        if (courseMetadata) {
            setGradingFormData(prevData => ({
                ...prevData,
                course: {
                    ...prevData.course,
                    code: courseMetadata.courseCode || prevData.course.code,
                    name: courseMetadata.courseName || prevData.course.name,
                    instructor: courseMetadata.instructor || prevData.course.instructor,
                    term: courseMetadata.term || prevData.course.term
                },
                assignment: {
                    ...prevData.assignment,
                    name: courseMetadata.assignmentName || prevData.assignment.name,
                    dueDate: courseMetadata.dueDate || prevData.assignment.dueDate,
                    maxPoints: courseMetadata.maxPoints || prevData.assignment.maxPoints
                }
            }));
        }

        return true;
    }, []);

    const updateGradingSession = useCallback((updates) => {
        setGradingSession(prev => ({
            ...prev,
            ...updates
        }));
    }, []);

    // ORIGINAL: Utility functions
    const transferRubricToGrading = useCallback(() => {
        if (sharedRubric) {
            setGradingFormData(prevData => ({
                ...prevData,
                assignment: {
                    ...prevData.assignment,
                    name: sharedRubric.assignmentInfo?.title || prevData.assignment.name,
                    maxPoints: sharedRubric.assignmentInfo?.totalPoints || prevData.assignment.maxPoints
                },
                metadata: {
                    ...prevData.metadata,
                    rubricIntegrated: true,
                    aiAssisted: sharedRubric.metadata?.aiGenerated || false
                }
            }));
        }
    }, [sharedRubric]);

    const transferRubricToGradingWithDetails = useCallback((courseDetails) => {
        transferRubricToGrading();
        if (courseDetails) {
            setGradingFormData(prevData => ({
                ...prevData,
                course: { ...prevData.course, ...courseDetails }
            }));
        }
    }, [transferRubricToGrading]);

    const clearSharedRubric = useCallback(() => {
        setSharedRubric(null);
    }, []);

    // ENHANCED: Session management with late policy data
    const exportSession = useCallback(() => {
        const sessionData = {
            rubric: sharedRubric,
            courseDetails: sharedCourseDetails,
            gradingData: gradingFormData,
            classList: classList,
            currentStudent: currentStudent,
            drafts: drafts,
            finalGrades: finalGrades,
            customLatePolicies: customLatePolicies,
            currentLatePolicy: currentLatePolicy,
            exportedAt: new Date().toISOString(),
            version: '2.0' // Updated version to include late policy data
        };

        const blob = new Blob([JSON.stringify(sessionData, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `grading-session-${new Date().toISOString().split('T')[0]}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
    }, [sharedRubric, sharedCourseDetails, gradingFormData, classList, currentStudent, drafts, finalGrades, customLatePolicies, currentLatePolicy]);

    const importSession = useCallback((sessionData) => {
        try {
            if (sessionData.rubric) setSharedRubric(sessionData.rubric);
            if (sessionData.courseDetails) setSharedCourseDetails(sessionData.courseDetails);
            if (sessionData.gradingData) setGradingFormData(sessionData.gradingData);
            if (sessionData.classList) setClassList(sessionData.classList);
            if (sessionData.currentStudent) setCurrentStudent(sessionData.currentStudent);
            if (sessionData.drafts) setDrafts(sessionData.drafts);
            if (sessionData.finalGrades) setFinalGrades(sessionData.finalGrades);
            
            // Import late policy data if available
            if (sessionData.customLatePolicies) setCustomLatePolicies(sessionData.customLatePolicies);
            if (sessionData.currentLatePolicy) setCurrentLatePolicy(sessionData.currentLatePolicy);

            console.log('✅ Session imported successfully with late policy data');
        } catch (error) {
            console.error("Failed to import session:", error);
            alert("Error: Could not load the session file. Please ensure it's a valid session file.");
        }
    }, []);

    const clearAllData = useCallback(() => {
        setSharedRubric(null);
        clearGradingFormData();
        clearRubricFormData();
        clearAIPromptFormData();
        clearAssignmentPromptFormData();
        setCustomLatePolicies([]);
        setCurrentLatePolicy(null);
    }, [clearGradingFormData, clearRubricFormData, clearAIPromptFormData, clearAssignmentPromptFormData]);

    const persistentFormData = gradingFormData;
    const updatePersistentFormData = setGradingFormData;

    const value = {
        // Shared state
        sharedRubric,
        setSharedRubric,
        sharedCourseDetails,
        setSharedCourseDetails,

        // Navigation
        activeTab,
        setActiveTab,

        // AI Prompt Generator (for rubrics)
        aiPromptFormData,
        updateAIPromptFormData,
        initializeAIPromptFormData,
        clearAIPromptFormData,

        // Assignment Prompt Generator
        assignmentPromptFormData,
        updateAssignmentPromptFormData,
        initializeAssignmentPromptFormData,
        clearAssignmentPromptFormData,

        // Grading form data
        gradingData: gradingFormData,
        setGradingData: setGradingFormData,
        clearGradingFormData,
        persistentFormData,
        updatePersistentFormData,

        // Form update functions
        updateStudentInfo,
        updateCourseInfo,
        updateAssignmentInfo,
        updateFeedbackInfo,
        updateAttachments,
        updateVideoLinks,
        updateLatePolicyInfo,
        updateRubricGrading,
        updateMetadata,

        // NEW: Late Policy Management
        currentLatePolicy,
        setCurrentLatePolicy,
        customLatePolicies,
        setCustomLatePolicies,
        saveCustomLatePolicy,
        updateCustomLatePolicy,
        deleteCustomLatePolicy,
        loadLatePoliciesFromStorage,
        applyLatePolicy,
        calculateScoreWithLatePolicy,

        // Draft and Final Grade Management - ENHANCED with Late Policy
        drafts,
        finalGrades,
        saveDraft,
        loadDraft,
        saveFinalGrade,
        loadFinalGrade,
        getGradeStatus,
        hasDraft,
        finalizeGrade,
        unlockGrade,

        // Class management
        classList,
        setClassList,
        currentStudent,
        setCurrentStudent,

        // Grading session
        gradingSession,
        setGradingSession,
        nextStudentInSession,
        previousStudentInSession,
        updateGradingSession,
        initializeGradingSession,

        // Rubric form data
        rubricFormData,
        setRubricFormData,

        // Utility functions
        transferRubricToGrading,
        transferRubricToGradingWithDetails,
        clearSharedRubric,
        clearRubricFormData,
        clearAllData,

        // Session management
        exportSession,
        importSession
    };

    return (
        <AssessmentContext.Provider value={value}>
            {children}
        </AssessmentContext.Provider>
    );
};

export default AssessmentProvider;